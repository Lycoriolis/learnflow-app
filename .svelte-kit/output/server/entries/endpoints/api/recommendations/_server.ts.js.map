{"version":3,"file":"_server.ts.js","sources":["../../../../../../../src/routes/api/recommendations/+server.ts"],"sourcesContent":["import { json, error } from '@sveltejs/kit';\nimport type { RequestHandler } from './$types';\nimport { getFirestore, collection, query, where, orderBy, limit as limitQuery, getDocs } from 'firebase/firestore';\nimport { getAllContentItemsByType, getContentNodeByPath, type ContentNode } from '$lib/server/contentService'; // Server import OK here\nimport { adminDb } from '$lib/server/firebaseAdmin';\n\ninterface SimpleLesson {\n  id: string;\n  title: string;\n  type: 'lesson';\n  path?: string; // Added path\n}\n\nexport interface Recommendation {\n  type: string;\n  referenceId: string;\n  title: string;\n  description: string;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Helper to find the next lesson within a course structure node.\n */\nfunction findNextLesson(node: ContentNode | null, currentLessonId: string): SimpleLesson | null {\n  if (!node || !node.children) return null;\n\n  for (const module of node.children) {\n    if (module.type === 'module' && module.children) {\n      const lessonIndex = module.children.findIndex((lesson) => lesson.type === 'lesson' && lesson.id === currentLessonId);\n      if (lessonIndex !== -1 && lessonIndex + 1 < module.children.length) {\n        const nextLesson = module.children[lessonIndex + 1];\n        if (nextLesson.type === 'lesson') {\n          // Ensure path is included if available\n          return {\n              id: nextLesson.id,\n              title: nextLesson.title || nextLesson.id,\n              type: 'lesson',\n              path: nextLesson.path\n          };\n        }\n      }\n    }\n  }\n  // Check next module if current lesson was the last in its module\n  for (let i = 0; i < node.children.length; i++) {\n      const module = node.children[i];\n      if (module.type === 'module' && module.children) {\n          const lessonIndex = module.children.findIndex((lesson) => lesson.type === 'lesson' && lesson.id === currentLessonId);\n          if (lessonIndex !== -1 && i + 1 < node.children.length) {\n              // Find the first lesson in the next module\n              const nextModule = node.children[i + 1];\n              if (nextModule.type === 'module' && nextModule.children) {\n                  const firstLessonOfNextModule = nextModule.children.find(lesson => lesson.type === 'lesson');\n                  if (firstLessonOfNextModule) {\n                      return {\n                          id: firstLessonOfNextModule.id,\n                          title: firstLessonOfNextModule.title || firstLessonOfNextModule.id,\n                          type: 'lesson',\n                          path: firstLessonOfNextModule.path\n                      };\n                  }\n              }\n          }\n      }\n  }\n\n  return null;\n}\n\n\nexport const GET: RequestHandler = async ({ locals, url }) => {\n  // Basic Auth Check (Adapt as needed based on your auth setup)\n  if (!locals.user) {\n    throw error(401, 'Unauthorized');\n  }\n  const userId = locals.user.uid;\n  const limit = parseInt(url.searchParams.get('limit') || '5', 10);\n\n  try {\n    // Use the initialized Firestore Admin instance\n    const db = adminDb;\n\n    const activitiesRef = collection(db, 'activities');\n\n    const q = query(\n      activitiesRef,\n      where('userId', '==', userId),\n      orderBy('timestamp', 'desc'),\n      limitQuery(limit * 2) // Fetch more activities to have options\n    );\n\n    const snapshot = await getDocs(q);\n    const acts = snapshot.docs.map(doc => ({\n      type: doc.data().eventType as string,\n      referenceId: doc.data().referenceId as string,\n      timestampStart: doc.data().timestamp, // Assuming timestamp is stored\n      metadata: doc.data().metadata || {}\n    }));\n\n    const recs: Recommendation[] = [];\n\n    // --- Recommendation Logic (Moved from service) ---\n\n    // 1. Next lesson based on last viewed lesson\n    const lastViewLesson = acts.find(a => a.type === 'view_lesson' && a.metadata?.courseId && a.referenceId);\n    if (lastViewLesson && lastViewLesson.metadata?.courseId) {\n        const courseId = lastViewLesson.metadata.courseId;\n        const lessonId = lastViewLesson.referenceId;\n        try {\n            const structureNode = await getContentNodeByPath('courses', courseId); // Use server function\n            if (structureNode) {\n                const nextLesson = findNextLesson(structureNode, lessonId);\n                if (nextLesson && !recs.some(r => r.type === 'next_lesson')) { // Avoid duplicates\n                    recs.push({\n                        type: 'next_lesson',\n                        referenceId: nextLesson.id,\n                        title: `Next: ${nextLesson.title}`,\n                        description: `Continue in ${structureNode.title || courseId}`,\n                        metadata: { \n                            courseId: typeof structureNode === 'object' && 'id' in structureNode ? structureNode.id : courseId, \n                            path: nextLesson.path \n                        } // Include path with safe access to id\n                    });\n                }\n            }\n        } catch (e) {\n            console.warn(`Error fetching course structure for ${courseId}:`, e);\n        }\n    }\n\n\n    // 2. Review flashcards suggestion (Simplified - needs actual logic based on your flashcard system)\n    const hasFlashcards = true; // Replace with actual check if user has flashcards\n    if (hasFlashcards && !recs.some(r => r.type === 'review_flashcards')) {\n        recs.push({\n            type: 'review_flashcards',\n            referenceId: '/tools/flashcards', // Link to the tool\n            title: 'Review your flashcards',\n            description: 'Keep your knowledge fresh with spaced repetition.',\n            metadata: { tool: 'flashcards' }\n        });\n    }\n\n    // 3. Suggest related exercises\n    const lastStartedExercise = acts.find(a => (a.type === 'start_exercise' || a.type === 'complete_exercise') && a.referenceId);\n    if (lastStartedExercise && recs.length < limit) {\n        try {\n            const allExercises = await getAllContentItemsByType('exercises', 'exercise'); // Use server function\n            const current = allExercises.find(e => e.id === lastStartedExercise.referenceId);\n            if (current?.tags) {\n                const userCompletedExercises = new Set(acts.filter(a => a.type === 'complete_exercise').map(a => a.referenceId));\n                const similar = allExercises.filter(e =>\n                    e.id !== current.id &&\n                    !userCompletedExercises.has(e.id) && // Don't suggest completed ones\n                    e.tags?.some(tag => current.tags?.includes(tag))\n                );\n                for (const ex of similar) {\n                    if (recs.length >= limit) break;\n                    if (!recs.some(r => r.referenceId === ex.id && r.type === 'exercise')) {\n                        recs.push({\n                            type: 'exercise',\n                            referenceId: ex.id,\n                            title: ex.title || ex.id,\n                            description: `Practice ${ex.tags?.join(', ') || 'related skills'}`, // Improved description\n                            metadata: { path: ex.path } // Include path\n                        });\n                    }\n                }\n            }\n        } catch (e) {\n            console.warn(`Error fetching exercises for recommendations:`, e);\n        }\n    }\n\n\n    // 4. Suggest new courses (not already started/completed)\n    if (recs.length < limit) {\n        try {\n            const allCourses = await getAllContentItemsByType('courses', 'course'); // Use server function\n            const userCourseProgress = new Map<string, number>();\n             acts.filter(a => a.type === 'start_course' || a.type === 'complete_course' || a.type === 'view_lesson')\n                 .forEach(a => {\n                     const courseId = a.metadata?.courseId || (a.type === 'start_course' ? a.referenceId : null);\n                     if (courseId) {\n                         const progress = a.type === 'complete_course' ? 100 : (userCourseProgress.get(courseId) || 1);\n                         userCourseProgress.set(courseId, progress);\n                     }\n                 });\n\n            const unstartedCourses = allCourses.filter(c => (userCourseProgress.get(c.id) || 0) < 100); // Suggest courses not completed\n\n            for (const course of unstartedCourses) {\n                if (recs.length >= limit) break;\n                 if (!recs.some(r => r.referenceId === course.id && r.type === 'course')) {\n                    recs.push({\n                        type: 'course',\n                        referenceId: course.id,\n                        title: course.title || course.id,\n                        description: course.description || `Explore ${course.title || course.id}`, // Fallback description\n                        metadata: { path: course.path } // Include path\n                    });\n                }\n            }\n        } catch (e) {\n            console.warn(`Error fetching courses for recommendations:`, e);\n        }\n    }\n\n    // --- End Recommendation Logic ---\n\n    return json(recs.slice(0, limit));\n\n  } catch (err: any) {\n    console.error(\"Error fetching recommendations:\", err);\n    // Ensure a proper error response is sent\n    throw error(err.status || 500, err.body?.message || err.message || 'Failed to fetch recommendations');\n  }\n};"],"names":["limit","limitQuery"],"mappings":";;;;AAwBA,SAAS,eAAe,MAA0B,iBAA8C;AAC9F,MAAI,CAAC,QAAQ,CAAC,KAAK,SAAiB,QAAA;AAEzB,aAAA,UAAU,KAAK,UAAU;AAClC,QAAI,OAAO,SAAS,YAAY,OAAO,UAAU;AACzC,YAAA,cAAc,OAAO,SAAS,UAAU,CAAC,WAAW,OAAO,SAAS,YAAY,OAAO,OAAO,eAAe;AACnH,UAAI,gBAAgB,MAAM,cAAc,IAAI,OAAO,SAAS,QAAQ;AAClE,cAAM,aAAa,OAAO,SAAS,cAAc,CAAC;AAC9C,YAAA,WAAW,SAAS,UAAU;AAEzB,iBAAA;AAAA,YACH,IAAI,WAAW;AAAA,YACf,OAAO,WAAW,SAAS,WAAW;AAAA,YACtC,MAAM;AAAA,YACN,MAAM,WAAW;AAAA,UACrB;AAAA,QAAA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGF,WAAS,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,KAAK;AACrC,UAAA,SAAS,KAAK,SAAS,CAAC;AAC9B,QAAI,OAAO,SAAS,YAAY,OAAO,UAAU;AACvC,YAAA,cAAc,OAAO,SAAS,UAAU,CAAC,WAAW,OAAO,SAAS,YAAY,OAAO,OAAO,eAAe;AACnH,UAAI,gBAAgB,MAAM,IAAI,IAAI,KAAK,SAAS,QAAQ;AAEpD,cAAM,aAAa,KAAK,SAAS,IAAI,CAAC;AACtC,YAAI,WAAW,SAAS,YAAY,WAAW,UAAU;AACrD,gBAAM,0BAA0B,WAAW,SAAS,KAAK,CAAU,WAAA,OAAO,SAAS,QAAQ;AAC3F,cAAI,yBAAyB;AAClB,mBAAA;AAAA,cACH,IAAI,wBAAwB;AAAA,cAC5B,OAAO,wBAAwB,SAAS,wBAAwB;AAAA,cAChE,MAAM;AAAA,cACN,MAAM,wBAAwB;AAAA,YAClC;AAAA,UAAA;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAGG,SAAA;AACT;AAGO,MAAM,MAAsB,OAAO,EAAE,QAAQ,UAAU;AAExD,MAAA,CAAC,OAAO,MAAM;AACV,UAAA,MAAM,KAAK,cAAc;AAAA,EAAA;AAE3B,QAAA,SAAS,OAAO,KAAK;AACrB,QAAAA,UAAQ,SAAS,IAAI,aAAa,IAAI,OAAO,KAAK,KAAK,EAAE;AAE3D,MAAA;AAEF,UAAM,KAAK;AAEL,UAAA,gBAAgB,WAAW,IAAI,YAAY;AAEjD,UAAM,IAAI;AAAA,MACR;AAAA,MACA,MAAM,UAAU,MAAM,MAAM;AAAA,MAC5B,QAAQ,aAAa,MAAM;AAAA,MAC3BC,MAAWD,UAAQ,CAAC;AAAA;AAAA,IACtB;AAEM,UAAA,WAAW,MAAM,QAAQ,CAAC;AAChC,UAAM,OAAO,SAAS,KAAK,IAAI,CAAQ,SAAA;AAAA,MACrC,MAAM,IAAI,KAAA,EAAO;AAAA,MACjB,aAAa,IAAI,KAAA,EAAO;AAAA,MACxB,gBAAgB,IAAI,KAAA,EAAO;AAAA;AAAA,MAC3B,UAAU,IAAI,KAAK,EAAE,YAAY,CAAA;AAAA,IAAC,EAClC;AAEF,UAAM,OAAyB,CAAC;AAK1B,UAAA,iBAAiB,KAAK,KAAK,CAAK,MAAA,EAAE,SAAS,iBAAiB,EAAE,UAAU,YAAY,EAAE,WAAW;AACnG,QAAA,kBAAkB,eAAe,UAAU,UAAU;AAC/C,YAAA,WAAW,eAAe,SAAS;AACzC,YAAM,WAAW,eAAe;AAC5B,UAAA;AACA,cAAM,gBAAgB,MAAM,qBAAqB,WAAW,QAAQ;AACpE,YAAI,eAAe;AACT,gBAAA,aAAa,eAAe,eAAe,QAAQ;AACrD,cAAA,cAAc,CAAC,KAAK,KAAK,OAAK,EAAE,SAAS,aAAa,GAAG;AACzD,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,aAAa,WAAW;AAAA,cACxB,OAAO,SAAS,WAAW,KAAK;AAAA,cAChC,aAAa,eAAe,cAAc,SAAS,QAAQ;AAAA,cAC3D,UAAU;AAAA,gBACN,UAAU,OAAO,kBAAkB,YAAY,QAAQ,gBAAgB,cAAc,KAAK;AAAA,gBAC1F,MAAM,WAAW;AAAA,cAAA;AAAA;AAAA,YACrB,CACH;AAAA,UAAA;AAAA,QACL;AAAA,eAEC,GAAG;AACR,gBAAQ,KAAK,uCAAuC,QAAQ,KAAK,CAAC;AAAA,MAAA;AAAA,IACtE;AAKJ,UAAM,gBAAgB;AAClB,QAAA,iBAAiB,CAAC,KAAK,KAAK,OAAK,EAAE,SAAS,mBAAmB,GAAG;AAClE,WAAK,KAAK;AAAA,QACN,MAAM;AAAA,QACN,aAAa;AAAA;AAAA,QACb,OAAO;AAAA,QACP,aAAa;AAAA,QACb,UAAU,EAAE,MAAM,aAAa;AAAA,MAAA,CAClC;AAAA,IAAA;AAIC,UAAA,sBAAsB,KAAK,KAAK,CAAM,OAAA,EAAE,SAAS,oBAAoB,EAAE,SAAS,wBAAwB,EAAE,WAAW;AACvH,QAAA,uBAAuB,KAAK,SAASA,SAAO;AACxC,UAAA;AACA,cAAM,eAAe,MAAM,yBAAyB,aAAa,UAAU;AAC3E,cAAM,UAAU,aAAa,KAAK,OAAK,EAAE,OAAO,oBAAoB,WAAW;AAC/E,YAAI,SAAS,MAAM;AACf,gBAAM,yBAAyB,IAAI,IAAI,KAAK,OAAO,CAAK,MAAA,EAAE,SAAS,mBAAmB,EAAE,IAAI,CAAK,MAAA,EAAE,WAAW,CAAC;AAC/G,gBAAM,UAAU,aAAa;AAAA,YAAO,CAAA,MAChC,EAAE,OAAO,QAAQ,MACjB,CAAC,uBAAuB,IAAI,EAAE,EAAE;AAAA,YAChC,EAAE,MAAM,KAAK,CAAA,QAAO,QAAQ,MAAM,SAAS,GAAG,CAAC;AAAA,UACnD;AACA,qBAAW,MAAM,SAAS;AAClB,gBAAA,KAAK,UAAUA,QAAO;AACtB,gBAAA,CAAC,KAAK,KAAK,CAAK,MAAA,EAAE,gBAAgB,GAAG,MAAM,EAAE,SAAS,UAAU,GAAG;AACnE,mBAAK,KAAK;AAAA,gBACN,MAAM;AAAA,gBACN,aAAa,GAAG;AAAA,gBAChB,OAAO,GAAG,SAAS,GAAG;AAAA,gBACtB,aAAa,YAAY,GAAG,MAAM,KAAK,IAAI,KAAK,gBAAgB;AAAA;AAAA,gBAChE,UAAU,EAAE,MAAM,GAAG,KAAK;AAAA;AAAA,cAAA,CAC7B;AAAA,YAAA;AAAA,UACL;AAAA,QACJ;AAAA,eAEC,GAAG;AACA,gBAAA,KAAK,iDAAiD,CAAC;AAAA,MAAA;AAAA,IACnE;AAKA,QAAA,KAAK,SAASA,SAAO;AACjB,UAAA;AACA,cAAM,aAAa,MAAM,yBAAyB,WAAW,QAAQ;AAC/D,cAAA,yCAAyB,IAAoB;AAClD,aAAK,OAAO,CAAA,MAAK,EAAE,SAAS,kBAAkB,EAAE,SAAS,qBAAqB,EAAE,SAAS,aAAa,EACjG,QAAQ,CAAK,MAAA;AACJ,gBAAA,WAAW,EAAE,UAAU,aAAa,EAAE,SAAS,iBAAiB,EAAE,cAAc;AACtF,cAAI,UAAU;AACJ,kBAAA,WAAW,EAAE,SAAS,oBAAoB,MAAO,mBAAmB,IAAI,QAAQ,KAAK;AACxE,+BAAA,IAAI,UAAU,QAAQ;AAAA,UAAA;AAAA,QAC7C,CACH;AAEA,cAAA,mBAAmB,WAAW,OAAO,CAAM,OAAA,mBAAmB,IAAI,EAAE,EAAE,KAAK,KAAK,GAAG;AAEzF,mBAAW,UAAU,kBAAkB;AAC/B,cAAA,KAAK,UAAUA,QAAO;AACrB,cAAA,CAAC,KAAK,KAAK,CAAK,MAAA,EAAE,gBAAgB,OAAO,MAAM,EAAE,SAAS,QAAQ,GAAG;AACtE,iBAAK,KAAK;AAAA,cACN,MAAM;AAAA,cACN,aAAa,OAAO;AAAA,cACpB,OAAO,OAAO,SAAS,OAAO;AAAA,cAC9B,aAAa,OAAO,eAAe,WAAW,OAAO,SAAS,OAAO,EAAE;AAAA;AAAA,cACvE,UAAU,EAAE,MAAM,OAAO,KAAK;AAAA;AAAA,YAAA,CACjC;AAAA,UAAA;AAAA,QACL;AAAA,eAEC,GAAG;AACA,gBAAA,KAAK,+CAA+C,CAAC;AAAA,MAAA;AAAA,IACjE;AAKJ,WAAO,KAAK,KAAK,MAAM,GAAGA,OAAK,CAAC;AAAA,WAEzB,KAAU;AACT,YAAA,MAAM,mCAAmC,GAAG;AAE9C,UAAA,MAAM,IAAI,UAAU,KAAK,IAAI,MAAM,WAAW,IAAI,WAAW,iCAAiC;AAAA,EAAA;AAExG;"}