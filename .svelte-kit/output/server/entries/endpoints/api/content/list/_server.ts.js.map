{"version":3,"file":"_server.ts.js","sources":["../../../../../../../../src/lib/services/contentService.ts","../../../../../../../../src/routes/api/content/list/+server.ts"],"sourcesContent":["import type { Timestamp } from 'firebase/firestore';\nimport type { ContentMetadata, ContentManifestItem, CourseStructure } from '$lib/types/contentTypes';\n\nexport { ContentMetadata, ContentManifestItem, CourseStructure };\n\n// Define the ContentNode type which represents courses and exercises\nexport interface ContentNode {\n  id: string;\n  title: string;\n  description?: string;\n  category?: string;\n  categories?: string[];\n  tags?: string[];\n  content?: string;\n  level?: 'beginner' | 'intermediate' | 'advanced';\n  duration?: string;\n  author?: string;\n  createdAt?: Date;\n  updatedAt?: Date;\n  isPublished?: boolean;\n  order?: number;\n  type?: 'course' | 'exercise' | 'module';\n  contentType?: 'courses' | 'exercises'; // Added for better type safety\n  prerequisites?: string[];\n  children?: ContentNode[];\n  parentId?: string;\n  slug?: string;\n  metadata?: {\n    dateAdded?: Timestamp;\n    popularity?: number;\n    difficulty?: number;\n    completionTime?: number;\n    viewCount?: number;\n    rating?: number;\n  };\n}\n\n// Define content metadata interface for admin views\nexport interface ContentMetadata {\n  id: string;\n  title: string;\n  type: 'course' | 'exercise' | 'module';\n  status: 'published' | 'draft' | 'archived';\n  author: string;\n  createdAt: Date;\n  updatedAt: Date;\n  viewCount: number;\n  completionCount: number;\n  averageRating: number;\n}\n\n// Define the Category interface\nexport interface Category {\n  id: string;\n  name: string;\n  description?: string;\n  icon?: string;\n  order?: number;\n  parentId?: string;\n  slug?: string;\n}\n\n// Cache for content data\nlet courseCache: Record<string, ContentNode[]> = {};\nlet exerciseCache: Record<string, ContentNode[]> = {};\nlet categoryCache: Record<string, Category[]> = {};\n\n/**\n * Fetches content from the specified path\n */\nexport async function fetchContent(type: 'courses' | 'exercises', path?: string): Promise<ContentNode[]> {\n  // If we have cached data, return it\n  if (type === 'courses' && courseCache[path || 'root']) {\n    return courseCache[path || 'root'];\n  }\n  if (type === 'exercises' && exerciseCache[path || 'root']) {\n    return exerciseCache[path || 'root'];\n  }\n\n  try {\n    // Build the path to fetch\n    const basePath = `/content/${type}`;\n    const fullPath = path ? `${basePath}/${path}/index.json` : `${basePath}/index.json`;\n    \n    const response = await fetch(fullPath);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch content: ${response.statusText}`);\n    }\n    \n    const data = await response.json();\n    let result: ContentNode[] = [];\n    \n    if (Array.isArray(data)) {\n      result = data;\n    } else if (data.items && Array.isArray(data.items)) {\n      result = data.items;\n    } else {\n      console.warn('Unexpected content format:', data);\n      result = [];\n    }\n    \n    // Cache the result\n    if (type === 'courses') {\n      courseCache[path || 'root'] = result;\n    } else {\n      exerciseCache[path || 'root'] = result;\n    }\n    \n    return result;\n  } catch (error) {\n    console.error(`Error fetching ${type}:`, error);\n    return [];\n  }\n}\n\n/**\n * Fetches categories for the specified content type\n */\nexport async function fetchCategories(type: 'courses' | 'exercises'): Promise<Category[]> {\n  if (categoryCache[type]) {\n    return categoryCache[type];\n  }\n  \n  try {\n    const response = await fetch(`/content/${type}/categories.json`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch categories: ${response.statusText}`);\n    }\n    \n    const data = await response.json();\n    categoryCache[type] = data;\n    return data;\n  } catch (error) {\n    console.error(`Error fetching ${type} categories:`, error);\n    return [];\n  }\n}\n\n/**\n * Fetches a specific content item by ID\n */\nexport async function fetchContentById(type: 'courses' | 'exercises', id: string): Promise<ContentNode | null> {\n  try {\n    const response = await fetch(`/content/${type}/${id}.json`);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch content: ${response.statusText}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error(`Error fetching ${type} by ID:`, error);\n    return null;\n  }\n}\n\n/**\n * Fetches a specific content item by slug\n */\nexport async function fetchContentBySlug(type: 'courses' | 'exercises', slug: string): Promise<ContentNode | null> {\n  try {\n    // First get all items\n    const items = await fetchContent(type);\n    \n    // Find the item with matching slug\n    const item = items.find(item => item.slug === slug);\n    if (item) {\n      return item;\n    }\n    \n    // If not found in the main list, try fetching directly\n    const response = await fetch(`/content/${type}/by-slug/${slug}.json`);\n    if (!response.ok) {\n      return null;\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error(`Error fetching ${type} by slug:`, error);\n    return null;\n  }\n}\n\n/**\n * Clear content caches\n */\nexport function clearContentCache() {\n  courseCache = {};\n  exerciseCache = {};\n  categoryCache = {};\n}\n\n/**\n * Lists content based on type and optional category identifier\n */\nexport async function listContent(type: string, categoryIdentifier?: string): Promise<ContentMetadata[]> {\n  // Implementation based on type and optional categoryIdentifier\n  // Return properly typed content metadata\n  return []; // Placeholder\n}\n\n/**\n * Fetches content by slug\n */\nexport async function getContent(slug: string): Promise<ContentManifestItem | null> {\n  if (!slug) return null;\n  // Implementation to fetch content by slug\n  return null; // Placeholder\n}\n\n/**\n * Fetches course structure by slug\n */\nexport async function getCourseStructure(slug: string): Promise<CourseStructure | null> {\n  if (!slug) return null;\n  // Implementation to fetch course structure\n  return null; // Placeholder\n}\n\n/**\n * Gets course gradient based on difficulty\n */\nexport function getCourseGradient(difficulty?: string): string {\n  switch (difficulty?.toLowerCase()) {\n    case 'beginner':\n      return 'from-green-400 to-green-600';\n    case 'intermediate':\n      return 'from-blue-400 to-blue-600';\n    case 'advanced':\n      return 'from-purple-400 to-purple-600';\n    case 'expert':\n      return 'from-red-400 to-red-600';\n    default:\n      return 'from-gray-400 to-gray-600';\n  }\n}\n\n/**\n * Finds the next lesson in a course structure\n */\nexport function findNextLesson(course: CourseStructure, currentLessonSlug: string): ContentManifestItem | null {\n  if (!course?.sections) return null;\n  \n  let foundCurrent = false;\n  \n  for (const section of course.sections) {\n    for (const lesson of section.lessons) {\n      if (foundCurrent) {\n        return lesson;\n      }\n      if (lesson.slug === currentLessonSlug) {\n        foundCurrent = true;\n      }\n    }\n  }\n  \n  return null;\n}\n","import { listContent } from '$lib/services/contentService';\n\nexport async function GET({ params }: { params: Record<string, string> }) {\n    const categoryIdentifier = params?.categoryId;\n    if (!categoryIdentifier) {\n        return new Response('Missing category identifier', { status: 400 });\n    }\n    const contentList = await listContent('course', categoryIdentifier);\n    return new Response(JSON.stringify(contentList), { status: 200 });\n}"],"names":[],"mappings":"AAkMsB,eAAA,YAAY,MAAc,oBAAyD;AAGvG,SAAO,CAAC;AACV;ACpMsB,eAAA,IAAI,EAAE,UAA8C;AACtE,QAAM,qBAAqB,QAAQ;AACnC,MAAI,CAAC,oBAAoB;AACrB,WAAO,IAAI,SAAS,+BAA+B,EAAE,QAAQ,KAAK;AAAA,EAAA;AAEtE,QAAM,cAAc,MAAM,YAAwC;AAC3D,SAAA,IAAI,SAAS,KAAK,UAAU,WAAW,GAAG,EAAE,QAAQ,KAAK;AACpE;"}