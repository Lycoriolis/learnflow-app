{"version":3,"file":"hooks.server.js","sources":["../../../../node_modules/@sveltejs/kit/src/exports/hooks/sequence.js","../../../../src/routes/api/csrfMiddleware.server.ts","../../../../src/routes/api/authMiddleware.server.ts","../../../../src/hooks.server.ts"],"sourcesContent":["/**\n * A helper function for sequencing multiple `handle` calls in a middleware-like manner.\n * The behavior for the `handle` options is as follows:\n * - `transformPageChunk` is applied in reverse order and merged\n * - `preload` is applied in forward order, the first option \"wins\" and no `preload` options after it are called\n * - `filterSerializedResponseHeaders` behaves the same as `preload`\n *\n * ```js\n * /// file: src/hooks.server.js\n * import { sequence } from '@sveltejs/kit/hooks';\n *\n * /// type: import('@sveltejs/kit').Handle\n * async function first({ event, resolve }) {\n * \tconsole.log('first pre-processing');\n * \tconst result = await resolve(event, {\n * \t\ttransformPageChunk: ({ html }) => {\n * \t\t\t// transforms are applied in reverse order\n * \t\t\tconsole.log('first transform');\n * \t\t\treturn html;\n * \t\t},\n * \t\tpreload: () => {\n * \t\t\t// this one wins as it's the first defined in the chain\n * \t\t\tconsole.log('first preload');\n * \t\t\treturn true;\n * \t\t}\n * \t});\n * \tconsole.log('first post-processing');\n * \treturn result;\n * }\n *\n * /// type: import('@sveltejs/kit').Handle\n * async function second({ event, resolve }) {\n * \tconsole.log('second pre-processing');\n * \tconst result = await resolve(event, {\n * \t\ttransformPageChunk: ({ html }) => {\n * \t\t\tconsole.log('second transform');\n * \t\t\treturn html;\n * \t\t},\n * \t\tpreload: () => {\n * \t\t\tconsole.log('second preload');\n * \t\t\treturn true;\n * \t\t},\n * \t\tfilterSerializedResponseHeaders: () => {\n * \t\t\t// this one wins as it's the first defined in the chain\n * \t\t\tconsole.log('second filterSerializedResponseHeaders');\n * \t\t\treturn true;\n * \t\t}\n * \t});\n * \tconsole.log('second post-processing');\n * \treturn result;\n * }\n *\n * export const handle = sequence(first, second);\n * ```\n *\n * The example above would print:\n *\n * ```\n * first pre-processing\n * first preload\n * second pre-processing\n * second filterSerializedResponseHeaders\n * second transform\n * first transform\n * second post-processing\n * first post-processing\n * ```\n *\n * @param {...import('@sveltejs/kit').Handle} handlers The chain of `handle` functions\n * @returns {import('@sveltejs/kit').Handle}\n */\nexport function sequence(...handlers) {\n\tconst length = handlers.length;\n\tif (!length) return ({ event, resolve }) => resolve(event);\n\n\treturn ({ event, resolve }) => {\n\t\treturn apply_handle(0, event, {});\n\n\t\t/**\n\t\t * @param {number} i\n\t\t * @param {import('@sveltejs/kit').RequestEvent} event\n\t\t * @param {import('@sveltejs/kit').ResolveOptions | undefined} parent_options\n\t\t * @returns {import('types').MaybePromise<Response>}\n\t\t */\n\t\tfunction apply_handle(i, event, parent_options) {\n\t\t\tconst handle = handlers[i];\n\n\t\t\treturn handle({\n\t\t\t\tevent,\n\t\t\t\tresolve: (event, options) => {\n\t\t\t\t\t/** @type {import('@sveltejs/kit').ResolveOptions['transformPageChunk']} */\n\t\t\t\t\tconst transformPageChunk = async ({ html, done }) => {\n\t\t\t\t\t\tif (options?.transformPageChunk) {\n\t\t\t\t\t\t\thtml = (await options.transformPageChunk({ html, done })) ?? '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (parent_options?.transformPageChunk) {\n\t\t\t\t\t\t\thtml = (await parent_options.transformPageChunk({ html, done })) ?? '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn html;\n\t\t\t\t\t};\n\n\t\t\t\t\t/** @type {import('@sveltejs/kit').ResolveOptions['filterSerializedResponseHeaders']} */\n\t\t\t\t\tconst filterSerializedResponseHeaders =\n\t\t\t\t\t\tparent_options?.filterSerializedResponseHeaders ??\n\t\t\t\t\t\toptions?.filterSerializedResponseHeaders;\n\n\t\t\t\t\t/** @type {import('@sveltejs/kit').ResolveOptions['preload']} */\n\t\t\t\t\tconst preload = parent_options?.preload ?? options?.preload;\n\n\t\t\t\t\treturn i < length - 1\n\t\t\t\t\t\t? apply_handle(i + 1, event, {\n\t\t\t\t\t\t\t\ttransformPageChunk,\n\t\t\t\t\t\t\t\tfilterSerializedResponseHeaders,\n\t\t\t\t\t\t\t\tpreload\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t: resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload });\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n}\n","/**\n * CSRF middleware for protecting API endpoints\n */\nimport type { Handle } from '@sveltejs/kit';\nimport { error } from '@sveltejs/kit';\nimport { validateCsrfToken, setupCsrfToken } from '$lib/utils/csrf.server';\nimport { CSRF_HEADER } from '$lib/utils/csrf.types';\n\n// Server-side only check\nif (typeof window !== 'undefined') {\n  throw new Error('csrfMiddleware.ts should only be imported on the server!');\n}\n\nexport const csrfProtect: Handle = async ({ event, resolve }) => {\n  // Skip CSRF check for GET requests (they should be idempotent)\n  if (event.request.method === 'GET') {\n    // Generate a new token for the next request\n    const newToken = setupCsrfToken(event.cookies);\n    const response = await resolve(event);\n    \n    // Add the token to response headers\n    const headers = new Headers(response.headers);\n    headers.set(CSRF_HEADER, newToken);\n    \n    return new Response(response.body, {\n      status: response.status,\n      statusText: response.statusText,\n      headers\n    });\n  }\n  \n  // For non-GET requests, validate the token\n  const headerToken = event.request.headers.get(CSRF_HEADER);\n  \n  if (!validateCsrfToken(event.cookies, headerToken)) {\n    throw error(403, {\n      message: 'CSRF token validation failed'\n    });\n  }\n  \n  // Generate a new token for the next request\n  const newToken = setupCsrfToken(event.cookies);\n  const response = await resolve(event);\n  \n  // Add the new token to response headers\n  const headers = new Headers(response.headers);\n  headers.set(CSRF_HEADER, newToken);\n  \n  return new Response(response.body, {\n    status: response.status,\n    statusText: response.statusText,\n    headers\n  });\n};","// Firebase authentication middleware for API routes\nimport type { Handle, RequestEvent } from '@sveltejs/kit';\n// Import adminAuth from the correct server-side file\nimport { adminAuth } from '$lib/server/firebaseAdmin';\nimport type { DecodedIdToken } from 'firebase-admin/auth';\n\n// Define the proper Locals interface\ninterface Locals {\n  user?: DecodedIdToken;\n  csrfToken?: string;\n  isAuthenticated?: boolean;\n}\n\n// Type for request event with decoded user\ninterface RequestEventWithAuth extends RequestEvent {\n  locals: Locals;\n}\n\n// Middleware that adds decoded Firebase token to `locals.user` if available\nexport const authMiddleware: Handle = async ({ event, resolve }) => {\n  const authHeader = event.request.headers.get('Authorization');\n  \n  if (authHeader && authHeader.startsWith('Bearer ')) {\n    const token = authHeader.slice(7);\n    try {\n      // Verify and decode the Firebase token\n      const decodedToken = await adminAuth.verifyIdToken(token);\n      // Add the decoded token to locals\n      event.locals.user = decodedToken;\n      console.log(`User authenticated: ${decodedToken.uid}`);\n    } catch (error) {\n      console.error('Token verification failed:', error);\n      // Don't set event.locals.user if token is invalid\n    }\n  }\n  \n  // Continue to the next middleware or route handler\n  return resolve(event);\n};\n\n// Middleware that requires authentication (for protected routes)\nexport const requireAuth: Handle = async ({ event, resolve }) => {\n  // First apply the standard auth middleware to verify and decode the token\n  await authMiddleware({ event, resolve: e => Promise.resolve(new Response()) });\n  \n  // Now check if user is authenticated\n  if (!event.locals.user) {\n    // No valid user found, return 401 Unauthorized\n    return new Response(JSON.stringify({ error: 'Unauthorized' }), {\n      status: 401,\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n  }\n  \n  // User is authenticated, continue to the next middleware or route handler\n  return resolve(event);\n};","// hooks.server.ts - Server-side only hooks\nimport type { Handle } from '@sveltejs/kit';\nimport { sequence } from '@sveltejs/kit/hooks';\nimport { csrfProtect } from './routes/api/csrfMiddleware.server.js';\nimport { authMiddleware, requireAuth } from './routes/api/authMiddleware.server.js';\n\n// Define API routes that require authentication\nconst authRequiredPaths = [\n  '/api/score',\n  '/api/recommendations',\n  '/api/activities'\n];\n\n// Chain middleware functions based on route\nexport const handle: Handle = async ({ event, resolve }) => {\n  // For API routes \n  if (event.url.pathname.startsWith('/api')) {\n    // Get base route without query parameters\n    const path = event.url.pathname;\n    \n    // For most API routes, apply authentication check after CSRF\n    if (authRequiredPaths.some(route => path.startsWith(route))) {\n      // Apply sequence of middlewares: first CSRF, then require authentication\n      return sequence(csrfProtect, requireAuth)({ event, resolve });\n    }\n    \n    // For other API routes like CSRF token refresh, just apply CSRF protection\n    return sequence(csrfProtect, authMiddleware)({ event, resolve });\n  }\n  \n  // For non-API routes, just pass through\n  return resolve(event);\n};"],"names":["event","handle","newToken","response","headers","error"],"mappings":"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","x_google_ignoreList":[0]}