{"version":3,"file":"MarkdownRenderer.js","sources":["../../../../src/lib/components/shared/MarkdownRenderer.svelte"],"sourcesContent":["<script lang=\"ts\">\n  import { onMount } from 'svelte';\n  import { marked } from 'marked';\n  import DOMPurify from 'dompurify';\n  import hljs from 'highlight.js';\n  import 'highlight.js/styles/github-dark.css';\n  import { afterUpdate } from 'svelte';\n  import { browser } from '$app/environment';\n\n  // Support both string and Promise<string> content\n  export let content: string | Promise<string> = '';\n  \n  let htmlContent: string = '';\n  let resolvedContent: string = '';\n  let isLoading = false;\n  let hasError = false;\n  let errorMessage = '';\n  \n  // Process markdown and sanitize HTML\n  function processMarkdown(markdownContent: string): string {\n    if (!markdownContent) return '';\n    \n    try {\n      return DOMPurify.sanitize(marked.parse(markdownContent, {\n        breaks: true,\n        gfm: true\n      }));\n    } catch (err) {\n      console.error('Error processing markdown:', err);\n      hasError = true;\n      errorMessage = err instanceof Error ? err.message : 'Unknown error processing markdown';\n      return '';\n    }\n  }\n  \n  // Handle content updates, including Promise resolution\n  $: {\n    if (content) {\n      if (typeof content === 'string') {\n        resolvedContent = content;\n        htmlContent = processMarkdown(content);\n      } else {\n        // It's a Promise\n        isLoading = true;\n        hasError = false;\n        \n        content\n          .then(result => {\n            resolvedContent = result;\n            htmlContent = processMarkdown(result);\n          })\n          .catch(err => {\n            console.error('Error resolving content:', err);\n            hasError = true;\n            errorMessage = err instanceof Error ? err.message : 'Failed to load content';\n          })\n          .finally(() => {\n            isLoading = false;\n          });\n      }\n    } else {\n      resolvedContent = '';\n      htmlContent = '';\n    }\n  }\n  \n  // Apply syntax highlighting only in the browser environment\n  function applySyntaxHighlighting() {\n    if (!browser) return;\n    \n    // Use setTimeout to ensure this runs after the DOM has been updated\n    setTimeout(() => {\n      const codeBlocks = document.querySelectorAll('pre code');\n      codeBlocks.forEach((block) => {\n        hljs.highlightElement(block as HTMLElement);\n      });\n    }, 0);\n  }\n  \n  // Apply highlighting after content updates\n  $: if (htmlContent && browser) {\n    applySyntaxHighlighting();\n  }\n  \n  // Also apply on mount and updates\n  onMount(() => {\n    if (htmlContent) {\n      applySyntaxHighlighting();\n    }\n  });\n  \n  afterUpdate(() => {\n    if (htmlContent) {\n      applySyntaxHighlighting();\n    }\n  });\n</script>\n\n<div class=\"markdown-content\">\n  {#if isLoading}\n    <div class=\"loading-indicator\">\n      <div class=\"spinner\"></div>\n      <p>Loading content...</p>\n    </div>\n  {:else if hasError}\n    <div class=\"error-message\">\n      <p>Error: {errorMessage}</p>\n    </div>\n  {:else}\n    {@html htmlContent}\n  {/if}\n</div>\n\n<style>\n  .markdown-content :global(pre) {\n    padding: 1rem;\n    border-radius: 0.5rem;\n    margin: 1rem 0;\n    overflow-x: auto;\n  }\n  \n  .markdown-content :global(code) {\n    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  }\n  \n  .markdown-content :global(p) {\n    margin-bottom: 1rem;\n  }\n  \n  .markdown-content :global(h1),\n  .markdown-content :global(h2),\n  .markdown-content :global(h3),\n  .markdown-content :global(h4),\n  .markdown-content :global(h5) {\n    margin-top: 1.5rem;\n    margin-bottom: 0.75rem;\n    font-weight: 600;\n  }\n  \n  .markdown-content :global(ul),\n  .markdown-content :global(ol) {\n    margin-left: 1.5rem;\n    margin-bottom: 1rem;\n  }\n  \n  .markdown-content :global(blockquote) {\n    border-left: 4px solid #e5e7eb;\n    padding-left: 1rem;\n    color: #6b7280;\n    margin: 1rem 0;\n  }\n  \n  .markdown-content :global(a) {\n    color: #3b82f6;\n    text-decoration: underline;\n  }\n  \n  .markdown-content :global(table) {\n    border-collapse: collapse;\n    width: 100%;\n    margin: 1rem 0;\n  }\n  \n  .markdown-content :global(th), \n  .markdown-content :global(td) {\n    border: 1px solid #e5e7eb;\n    padding: 0.5rem;\n  }\n  \n  .markdown-content :global(th) {\n    background-color: #f3f4f6;\n  }\n  \n  .loading-indicator {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    justify-content: center;\n    padding: 2rem 0;\n  }\n  \n  .spinner {\n    border: 3px solid rgba(0, 0, 0, 0.1);\n    border-radius: 50%;\n    border-top: 3px solid #3498db;\n    width: 24px;\n    height: 24px;\n    animation: spin 1s linear infinite;\n    margin-bottom: 0.5rem;\n  }\n  \n  @keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n  }\n  \n  .error-message {\n    padding: 1rem;\n    background-color: #fee2e2;\n    border: 1px solid #fecaca;\n    border-radius: 0.5rem;\n    color: #b91c1c;\n  }\n</style>"],"names":[],"mappings":";;;;;;;;;AAUa,MAAA,uCAAoC,EAAE;AAE7C,MAAA,cAAsB;AAEtB,MAAA,YAAY;AACZ,MAAA,WAAW;AACX,MAAA,eAAe;WAGV,gBAAgB,iBAAiC;AACnD,QAAA,CAAA,wBAAwB;AAEzB,QAAA;AACK,aAAA,UAAU,SAAS,OAAO,MAAM,iBAAe,EACpD,QAAQ,MACR,KAAK,KAAA,CAAA,CAAA;AAAA,IAER,SAAQ,KAAK;AACZ,cAAQ,MAAM,8BAA8B,GAAG;AAC/C,iBAAW;AACX,qBAAe,eAAe,QAAQ,IAAI,UAAU;aAC7C;AAAA,IACT;AAAA,EACF;AAGG;AACG,QAAA,SAAS;iBACA,YAAY,UAAU;AAE/B,sBAAc,gBAAgB,OAAO;AAAA,MACvC,OAAO;AAEL,oBAAY;AACZ,mBAAW;AAEX,gBACG,KAAK,CAAA,WAAU;AAEd,wBAAc,gBAAgB,MAAM;AAAA,QACtC,CAAC,EACA,MAAM,CAAA,QAAO;AACZ,kBAAQ,MAAM,4BAA4B,GAAG;AAC7C,qBAAW;AACX,yBAAe,eAAe,QAAQ,IAAI,UAAU;AAAA,SACrD,EACA,QAAc,MAAA;AACb,sBAAY;AAAA,SACb;AAAA,MACL;AAAA,IACF,OAAO;AAEL,oBAAc;AAAA,IAChB;AAAA,EACF;;MAmCK,WAAS;;;aAKJ,UAAQ;;+GAEH,YAAY,CAAA;AAAA;;6BAGlB,WAAW,CAAA;AAAA;;;;;"}