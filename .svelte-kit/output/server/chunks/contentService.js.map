{"version":3,"file":"contentService.js","sources":["../../../../src/lib/server/contentService.ts"],"sourcesContent":["import { readFile, readdir } from 'fs/promises';\nimport { join, dirname, basename } from 'path';\nimport { marked } from 'marked';\nimport hljs from 'highlight.js';\nimport type { ContentNode, ContentManifestItem } from '../types/shared';\nimport { error } from '@sveltejs/kit';\n\n// Configure marked for better markdown rendering\nmarked.setOptions({\n\thighlight: function(code: string, lang: string) {\n\t\tif (lang && hljs.getLanguage(lang)) {\n\t\t\ttry {\n\t\t\t\treturn hljs.highlight(code, { language: lang }).value;\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn('Error highlighting code:', e);\n\t\t\t}\n\t\t}\n\t\treturn code;\n\t},\n\tgfm: true, // GitHub Flavored Markdown\n\tbreaks: true, // Convert line breaks to <br>\n\theaderIds: true, // Add IDs to headers\n\tmangle: false, // Don't mangle header IDs\n\tsanitize: false, // Don't sanitize HTML\n\tsmartLists: true, // Use smart list behavior\n\tsmartypants: true, // Use smart typography\n\txhtml: true // Use XHTML-compatible tags\n});\n\n// Cache for content nodes\nconst contentCache: Record<string, ContentNode> = {};\nconst manifestCache: Record<string, ContentManifestItem[]> = {};\n\n// Raw structure from JSON files might differ\ninterface RawCourseManifest {\n\tcategories: ContentManifestItem[];\n\tfeaturedCourses?: any[]; // Keep other potential top-level keys\n\t// ... other potential top-level keys\n}\n\ninterface RawExerciseManifest {\n\texercises: ContentManifestItem[];\n\tcategories: ContentManifestItem[];\n\tfeaturedExercises?: any[]; // Keep other potential top-level keys\n\t// ... other potential top-level keys\n}\n\n// The structure we *want* after processing\ninterface ProcessedContentManifest {\n\titems: ContentManifestItem[];\n\t// We might store other processed data here if needed\n}\n\n/**\n * Loads the content manifest for a given type\n */\nasync function loadContentManifest(type: string): Promise<ContentManifestItem[]> {\n\tif (manifestCache[type]) {\n\t\treturn manifestCache[type];\n\t}\n\n\ttry {\n\t\tconst manifestPath = join(process.cwd(), 'static', 'content', type, 'manifest.json');\n\t\tconst manifestContent = await readFile(manifestPath, 'utf-8');\n\t\tconst manifest = JSON.parse(manifestContent);\n\t\tmanifestCache[type] = manifest;\n\t\treturn manifest;\n\t} catch (error) {\n\t\tconsole.error(`Error loading manifest for ${type}:`, error);\n\t\treturn [];\n\t}\n}\n\n/**\n * Recursively finds a content node by identifier\n */\nfunction findNodeByIdentifier(\n\tmanifest: ContentManifestItem[],\n\tidentifier: string\n): ContentManifestItem | null {\n\tfor (const item of manifest) {\n\t\tif (item.id === identifier || item.slug === identifier) {\n\t\t\treturn item;\n\t\t}\n\t\tif (item.children) {\n\t\t\tconst found = findNodeByIdentifier(item.children, identifier);\n\t\t\tif (found) return found;\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Gets a content node by identifier\n */\nexport async function getContentNodeByIdentifier(\n\ttype: string,\n\tidentifier: string\n): Promise<ContentNode> {\n\tconst cacheKey = `${type}:${identifier}`;\n\tif (contentCache[cacheKey]) {\n\t\treturn contentCache[cacheKey];\n\t}\n\n\tconst manifest = await loadContentManifest(type);\n\tconst node = findNodeByIdentifier(manifest, identifier);\n\n\tif (!node) {\n\t\tthrow new Error(`Content node not found: ${identifier}`);\n\t}\n\n\t// Load markdown content if it's a content node\n\tlet markdownContent = '';\n\tlet contentLoadingError: string | undefined;\n\n\tif (node.type === 'course' || node.type === 'lesson' || node.type === 'module') {\n\t\ttry {\n\t\t\tconst contentPath = join(process.cwd(), 'static', 'content', type, node.path || `${node.id}.md`);\n\t\t\tconst content = await readFile(contentPath, 'utf-8');\n\t\t\tmarkdownContent = marked(content);\n\t\t} catch (error) {\n\t\t\tconsole.error(`Error loading content for ${identifier}:`, error);\n\t\t\tcontentLoadingError = error instanceof Error ? error.message : 'Failed to load content';\n\t\t}\n\t}\n\n\tconst contentNode: ContentNode = {\n\t\t...node,\n\t\tmarkdownContent,\n\t\tcontentLoadingError\n\t};\n\n\tcontentCache[cacheKey] = contentNode;\n\treturn contentNode;\n}\n\n/**\n * Gets content nodes by path\n */\nexport async function getContentNodeByPath(\n\ttype: string,\n\tpath: string\n): Promise<ContentNode | null> {\n\tconst manifest = await loadContentManifest(type);\n\tconst pathParts = path.split('/').filter(Boolean);\n\t\n\tlet currentItems = manifest;\n\tlet currentNode: ContentManifestItem | null = null;\n\n\tfor (const part of pathParts) {\n\t\tcurrentNode = currentItems.find(item => item.id === part || item.slug === part) || null;\n\t\tif (!currentNode || !currentNode.children) {\n\t\t\tbreak;\n\t\t}\n\t\tcurrentItems = currentNode.children;\n\t}\n\n\tif (!currentNode) {\n\t\treturn null;\n\t}\n\n\treturn getContentNodeByIdentifier(type, currentNode.id);\n}\n\n/**\n * Gets breadcrumbs for a content path\n */\nexport async function getBreadcrumbs(\n\ttype: string,\n\tpath: string\n): Promise<ContentManifestItem[]> {\n\tconst manifest = await loadContentManifest(type);\n\tconst pathParts = path.split('/').filter(Boolean);\n\tconst breadcrumbs: ContentManifestItem[] = [];\n\n\tlet currentItems = manifest;\n\tfor (const part of pathParts) {\n\t\tconst node = currentItems.find(item => item.id === part || item.slug === part);\n\t\tif (node) {\n\t\t\tbreadcrumbs.push(node);\n\t\t\tif (node.children) {\n\t\t\t\tcurrentItems = node.children;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn breadcrumbs;\n}\n\n/**\n * Gets all content items of a specific type\n */\nexport async function getAllContentItemsByType(\n\ttype: string,\n\titemType: string\n): Promise<ContentManifestItem[]> {\n\tconst manifest = await loadContentManifest(type);\n\tconst items: ContentManifestItem[] = [];\n\n\tfunction collectItems(node: ContentManifestItem) {\n\t\tif (node.type === itemType) {\n\t\t\titems.push(node);\n\t\t}\n\t\tif (node.children) {\n\t\t\tnode.children.forEach(collectItems);\n\t\t}\n\t}\n\n\tmanifest.forEach(collectItems);\n\treturn items;\n}\n\n/**\n * Gets content list by category\n */\nexport async function getContentListByCategory(\n\ttype: string,\n\tcategoryIdentifier: string\n): Promise<ContentManifestItem[]> {\n\tconst manifest = await loadContentManifest(type);\n\tconst category = findNodeByIdentifier(manifest, categoryIdentifier);\n\n\tif (!category || !category.children) {\n\t\treturn [];\n\t}\n\n\treturn category.children;\n}\n\n/**\n * Gets suggested content items\n */\nexport async function getSuggestedContentItems(\n\ttype: string,\n\titemType: string,\n\tenrolledIds: string[] = []\n): Promise<ContentManifestItem[]> {\n\tconst manifest = await loadContentManifest(type);\n\tconst items: ContentManifestItem[] = [];\n\n\tfunction collectItems(node: ContentManifestItem) {\n\t\tif (node.type === itemType && !enrolledIds.includes(node.id)) {\n\t\t\titems.push(node);\n\t\t}\n\t\tif (node.children) {\n\t\t\tnode.children.forEach(collectItems);\n\t\t}\n\t}\n\n\tmanifest.forEach(collectItems);\n\treturn items;\n}\n\n/**\n * Clears the content cache\n */\nexport function clearContentCache(): void {\n\tObject.keys(contentCache).forEach(key => delete contentCache[key]);\n\tObject.keys(manifestCache).forEach(key => delete manifestCache[key]);\n}\n\n// Alias for legacy route imports\nexport { getContentNodeByIdentifier as loadContent };\nexport { getContentListByCategory as listContent };\n"],"names":["error"],"mappings":"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"}