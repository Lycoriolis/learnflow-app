{"version":3,"file":"csrf.server.js","sources":["../../../../src/lib/utils/csrf.types.ts","../../../../src/lib/utils/csrf.server.ts"],"sourcesContent":["/**\n * Shared CSRF types and constants for both client and server\n * This file should only contain types, interfaces, and constants\n * No implementation code should be here\n */\n\n// The header name used for CSRF token transmission\nexport const CSRF_HEADER = 'X-CSRF-Token';\n\n// Cookie name for CSRF token storage\nexport const CSRF_COOKIE = 'csrf_token';\n\n// Interface for CSRF token responses\nexport interface CsrfToken {\n  token: string;\n}","/**\n * Server-side CSRF protection utilities\n * This file should never be imported on the client\n */\nimport { CSRF_HEADER, CSRF_COOKIE } from './csrf.types.js';\nimport { env } from '$env/dynamic/private';\nimport type { Cookies } from '@sveltejs/kit';\nimport crypto from 'crypto';\n\n// Make sure this file only runs on the server\nif (typeof window !== 'undefined') {\n  throw new Error('csrf.server.ts should only be imported on the server!');\n}\n\n// Secret used for CSRF token validation\nconst CSRF_SECRET = env.VITE_CSRF_SECRET || 'default-csrf-secret-key-should-be-changed-in-production';\n\n/**\n * Generate a cryptographically secure random token\n */\nexport function generateToken(): string {\n  return crypto.randomBytes(32).toString('hex');\n}\n\n/**\n * Set up CSRF protection by generating and storing a token in cookies\n */\nexport function setupCsrfToken(cookies: Cookies): string {\n  const token = generateToken();\n  \n  cookies.set(CSRF_COOKIE, token, {\n    path: '/',\n    httpOnly: true,\n    sameSite: 'strict',\n    secure: process.env.NODE_ENV === 'production',\n    maxAge: 60 * 60 * 24 // 24 hours\n  });\n\n  return token;\n}\n\n/**\n * Hash a token for secure comparison\n */\nfunction hashToken(token: string): string {\n  return crypto\n    .createHmac('sha256', CSRF_SECRET)\n    .update(token)\n    .digest('hex');\n}\n\n/**\n * Validate a CSRF token against the cookie using constant-time comparison\n */\nexport function validateCsrfToken(cookies: Cookies, headerToken: string | null): boolean {\n  if (!headerToken) return false;\n\n  const cookieToken = cookies.get(CSRF_COOKIE);\n  if (!cookieToken) return false;\n\n  try {\n    // Use constant-time comparison to prevent timing attacks\n    return crypto.timingSafeEqual(\n      Buffer.from(hashToken(headerToken)),\n      Buffer.from(hashToken(cookieToken))\n    );\n  } catch (error) {\n    console.error('CSRF validation error:', error);\n    return false;\n  }\n}"],"names":["env"],"mappings":";;AAOO,MAAM,cAAc;AAGpB,MAAM,cAAc;ACA3B,IAAI,OAAO,WAAW,aAAa;AAC3B,QAAA,IAAI,MAAM,uDAAuD;AACzE;AAGA,MAAM,cAAcA,YAAI,oBAAoB;AAKrC,SAAS,gBAAwB;AACtC,SAAO,OAAO,YAAY,EAAE,EAAE,SAAS,KAAK;AAC9C;AAKO,SAAS,eAAe,SAA0B;AACvD,QAAM,QAAQ,cAAc;AAEpB,UAAA,IAAI,aAAa,OAAO;AAAA,IAC9B,MAAM;AAAA,IACN,UAAU;AAAA,IACV,UAAU;AAAA,IACV,QAAQ,QAAQ,IAAI,aAAa;AAAA,IACjC,QAAQ,KAAK,KAAK;AAAA;AAAA,EAAA,CACnB;AAEM,SAAA;AACT;AAKA,SAAS,UAAU,OAAuB;AACjC,SAAA,OACJ,WAAW,UAAU,WAAW,EAChC,OAAO,KAAK,EACZ,OAAO,KAAK;AACjB;AAKgB,SAAA,kBAAkB,SAAkB,aAAqC;AACnF,MAAA,CAAC,YAAoB,QAAA;AAEnB,QAAA,cAAc,QAAQ,IAAI,WAAW;AACvC,MAAA,CAAC,YAAoB,QAAA;AAErB,MAAA;AAEF,WAAO,OAAO;AAAA,MACZ,OAAO,KAAK,UAAU,WAAW,CAAC;AAAA,MAClC,OAAO,KAAK,UAAU,WAAW,CAAC;AAAA,IACpC;AAAA,WACO,OAAO;AACN,YAAA,MAAM,0BAA0B,KAAK;AACtC,WAAA;AAAA,EAAA;AAEX;"}