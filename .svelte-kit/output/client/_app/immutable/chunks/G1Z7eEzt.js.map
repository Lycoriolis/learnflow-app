{"version":3,"file":"G1Z7eEzt.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/elements/style.js","../../../../../../node_modules/svelte/src/internal/client/dom/elements/attributes.js"],"sourcesContent":["import { to_style } from '../../../shared/attributes.js';\nimport { hydrating } from '../hydration.js';\n\n/**\n * @param {Element & ElementCSSInlineStyle} dom\n * @param {Record<string, any>} prev\n * @param {Record<string, any>} next\n * @param {string} [priority]\n */\nfunction update_styles(dom, prev = {}, next, priority) {\n\tfor (var key in next) {\n\t\tvar value = next[key];\n\n\t\tif (prev[key] !== value) {\n\t\t\tif (next[key] == null) {\n\t\t\t\tdom.style.removeProperty(key);\n\t\t\t} else {\n\t\t\t\tdom.style.setProperty(key, value, priority);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} dom\n * @param {string | null} value\n * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [prev_styles]\n * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [next_styles]\n */\nexport function set_style(dom, value, prev_styles, next_styles) {\n\t// @ts-expect-error\n\tvar prev = dom.__style;\n\n\tif (hydrating || prev !== value) {\n\t\tvar next_style_attr = to_style(value, next_styles);\n\n\t\tif (!hydrating || next_style_attr !== dom.getAttribute('style')) {\n\t\t\tif (next_style_attr == null) {\n\t\t\t\tdom.removeAttribute('style');\n\t\t\t} else {\n\t\t\t\tdom.style.cssText = next_style_attr;\n\t\t\t}\n\t\t}\n\n\t\t// @ts-expect-error\n\t\tdom.__style = value;\n\t} else if (next_styles) {\n\t\tif (Array.isArray(next_styles)) {\n\t\t\tupdate_styles(dom, prev_styles?.[0], next_styles[0]);\n\t\t\tupdate_styles(dom, prev_styles?.[1], next_styles[1], 'important');\n\t\t} else {\n\t\t\tupdate_styles(dom, prev_styles, next_styles);\n\t\t}\n\t}\n\n\treturn next_styles;\n}\n","import { DEV } from 'esm-env';\nimport { hydrating, set_hydrating } from '../hydration.js';\nimport { get_descriptors, get_prototype_of } from '../../../shared/utils.js';\nimport { create_event, delegate } from './events.js';\nimport { add_form_reset_listener, autofocus } from './misc.js';\nimport * as w from '../../warnings.js';\nimport { LOADING_ATTR_SYMBOL } from '#client/constants';\nimport { queue_idle_task } from '../task.js';\nimport { is_capture_event, is_delegated, normalize_attribute } from '../../../../utils.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../runtime.js';\nimport { clsx } from '../../../shared/attributes.js';\nimport { set_class } from './class.js';\nimport { set_style } from './style.js';\nimport { NAMESPACE_HTML } from '../../../../constants.js';\n\nexport const CLASS = Symbol('class');\nexport const STYLE = Symbol('style');\n\nconst IS_CUSTOM_ELEMENT = Symbol('is custom element');\nconst IS_HTML = Symbol('is html');\n\n/**\n * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLInputElement} input\n * @returns {void}\n */\nexport function remove_input_defaults(input) {\n\tif (!hydrating) return;\n\n\tvar already_removed = false;\n\n\t// We try and remove the default attributes later, rather than sync during hydration.\n\t// Doing it sync during hydration has a negative impact on performance, but deferring the\n\t// work in an idle task alleviates this greatly. If a form reset event comes in before\n\t// the idle callback, then we ensure the input defaults are cleared just before.\n\tvar remove_defaults = () => {\n\t\tif (already_removed) return;\n\t\talready_removed = true;\n\n\t\t// Remove the attributes but preserve the values\n\t\tif (input.hasAttribute('value')) {\n\t\t\tvar value = input.value;\n\t\t\tset_attribute(input, 'value', null);\n\t\t\tinput.value = value;\n\t\t}\n\n\t\tif (input.hasAttribute('checked')) {\n\t\t\tvar checked = input.checked;\n\t\t\tset_attribute(input, 'checked', null);\n\t\t\tinput.checked = checked;\n\t\t}\n\t};\n\n\t// @ts-expect-error\n\tinput.__on_r = remove_defaults;\n\tqueue_idle_task(remove_defaults);\n\tadd_form_reset_listener();\n}\n\n/**\n * @param {Element} element\n * @param {any} value\n */\nexport function set_value(element, value) {\n\tvar attributes = get_attributes(element);\n\n\tif (\n\t\tattributes.value ===\n\t\t\t(attributes.value =\n\t\t\t\t// treat null and undefined the same for the initial value\n\t\t\t\tvalue ?? undefined) ||\n\t\t// @ts-expect-error\n\t\t// `progress` elements always need their value set when it's `0`\n\t\t(element.value === value && (value !== 0 || element.nodeName !== 'PROGRESS'))\n\t) {\n\t\treturn;\n\t}\n\n\t// @ts-expect-error\n\telement.value = value ?? '';\n}\n\n/**\n * @param {Element} element\n * @param {boolean} checked\n */\nexport function set_checked(element, checked) {\n\tvar attributes = get_attributes(element);\n\n\tif (\n\t\tattributes.checked ===\n\t\t(attributes.checked =\n\t\t\t// treat null and undefined the same for the initial value\n\t\t\tchecked ?? undefined)\n\t) {\n\t\treturn;\n\t}\n\n\t// @ts-expect-error\n\telement.checked = checked;\n}\n\n/**\n * Sets the `selected` attribute on an `option` element.\n * Not set through the property because that doesn't reflect to the DOM,\n * which means it wouldn't be taken into account when a form is reset.\n * @param {HTMLOptionElement} element\n * @param {boolean} selected\n */\nexport function set_selected(element, selected) {\n\tif (selected) {\n\t\t// The selected option could've changed via user selection, and\n\t\t// setting the value without this check would set it back.\n\t\tif (!element.hasAttribute('selected')) {\n\t\t\telement.setAttribute('selected', '');\n\t\t}\n\t} else {\n\t\telement.removeAttribute('selected');\n\t}\n}\n\n/**\n * Applies the default checked property without influencing the current checked property.\n * @param {HTMLInputElement} element\n * @param {boolean} checked\n */\nexport function set_default_checked(element, checked) {\n\tconst existing_value = element.checked;\n\telement.defaultChecked = checked;\n\telement.checked = existing_value;\n}\n\n/**\n * Applies the default value property without influencing the current value property.\n * @param {HTMLInputElement | HTMLTextAreaElement} element\n * @param {string} value\n */\nexport function set_default_value(element, value) {\n\tconst existing_value = element.value;\n\telement.defaultValue = value;\n\telement.value = existing_value;\n}\n\n/**\n * @param {Element} element\n * @param {string} attribute\n * @param {string | null} value\n * @param {boolean} [skip_warning]\n */\nexport function set_attribute(element, attribute, value, skip_warning) {\n\tvar attributes = get_attributes(element);\n\n\tif (hydrating) {\n\t\tattributes[attribute] = element.getAttribute(attribute);\n\n\t\tif (\n\t\t\tattribute === 'src' ||\n\t\t\tattribute === 'srcset' ||\n\t\t\t(attribute === 'href' && element.nodeName === 'LINK')\n\t\t) {\n\t\t\tif (!skip_warning) {\n\t\t\t\tcheck_src_in_dev_hydration(element, attribute, value ?? '');\n\t\t\t}\n\n\t\t\t// If we reset these attributes, they would result in another network request, which we want to avoid.\n\t\t\t// We assume they are the same between client and server as checking if they are equal is expensive\n\t\t\t// (we can't just compare the strings as they can be different between client and server but result in the\n\t\t\t// same url, so we would need to create hidden anchor elements to compare them)\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (attributes[attribute] === (attributes[attribute] = value)) return;\n\n\tif (attribute === 'loading') {\n\t\t// @ts-expect-error\n\t\telement[LOADING_ATTR_SYMBOL] = value;\n\t}\n\n\tif (value == null) {\n\t\telement.removeAttribute(attribute);\n\t} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {\n\t\t// @ts-ignore\n\t\telement[attribute] = value;\n\t} else {\n\t\telement.setAttribute(attribute, value);\n\t}\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {string} value\n */\nexport function set_xlink_attribute(dom, attribute, value) {\n\tdom.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @param {string} prop\n * @param {any} value\n */\nexport function set_custom_element_data(node, prop, value) {\n\t// We need to ensure that setting custom element props, which can\n\t// invoke lifecycle methods on other custom elements, does not also\n\t// associate those lifecycle methods with the current active reaction\n\t// or effect\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\n\t// If we're hydrating but the custom element is from Svelte, and it already scaffolded,\n\t// then it might run block logic in hydration mode, which we have to prevent.\n\tlet was_hydrating = hydrating;\n\tif (hydrating) {\n\t\tset_hydrating(false);\n\t}\n\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\n\ttry {\n\t\tif (\n\t\t\t// `style` should use `set_attribute` rather than the setter\n\t\t\tprop !== 'style' &&\n\t\t\t// Don't compute setters for custom elements while they aren't registered yet,\n\t\t\t// because during their upgrade/instantiation they might add more setters.\n\t\t\t// Instead, fall back to a simple \"an object, then set as property\" heuristic.\n\t\t\t(setters_cache.has(node.nodeName) ||\n\t\t\t// customElements may not be available in browser extension contexts\n\t\t\t!customElements ||\n\t\t\tcustomElements.get(node.tagName.toLowerCase())\n\t\t\t\t? get_setters(node).includes(prop)\n\t\t\t\t: value && typeof value === 'object')\n\t\t) {\n\t\t\t// @ts-expect-error\n\t\t\tnode[prop] = value;\n\t\t} else {\n\t\t\t// We did getters etc checks already, stringify before passing to set_attribute\n\t\t\t// to ensure it doesn't invoke the same logic again, and potentially populating\n\t\t\t// the setters cache too early.\n\t\t\tset_attribute(node, prop, value == null ? value : String(value));\n\t\t}\n\t} finally {\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t\tif (was_hydrating) {\n\t\t\tset_hydrating(true);\n\t\t}\n\t}\n}\n\n/**\n * Spreads attributes onto a DOM element, taking into account the currently set attributes\n * @param {Element & ElementCSSInlineStyle} element\n * @param {Record<string | symbol, any> | undefined} prev\n * @param {Record<string | symbol, any>} next New attributes - this function mutates this object\n * @param {string} [css_hash]\n * @param {boolean} [skip_warning]\n * @returns {Record<string, any>}\n */\nexport function set_attributes(element, prev, next, css_hash, skip_warning = false) {\n\tvar attributes = get_attributes(element);\n\n\tvar is_custom_element = attributes[IS_CUSTOM_ELEMENT];\n\tvar preserve_attribute_case = !attributes[IS_HTML];\n\n\t// If we're hydrating but the custom element is from Svelte, and it already scaffolded,\n\t// then it might run block logic in hydration mode, which we have to prevent.\n\tlet is_hydrating_custom_element = hydrating && is_custom_element;\n\tif (is_hydrating_custom_element) {\n\t\tset_hydrating(false);\n\t}\n\n\tvar current = prev || {};\n\tvar is_option_element = element.tagName === 'OPTION';\n\n\tfor (var key in prev) {\n\t\tif (!(key in next)) {\n\t\t\tnext[key] = null;\n\t\t}\n\t}\n\n\tif (next.class) {\n\t\tnext.class = clsx(next.class);\n\t} else if (css_hash || next[CLASS]) {\n\t\tnext.class = null; /* force call to set_class() */\n\t}\n\n\tif (next[STYLE]) {\n\t\tnext.style ??= null; /* force call to set_style() */\n\t}\n\n\tvar setters = get_setters(element);\n\n\t// since key is captured we use const\n\tfor (const key in next) {\n\t\t// let instead of var because referenced in a closure\n\t\tlet value = next[key];\n\n\t\t// Up here because we want to do this for the initial value, too, even if it's undefined,\n\t\t// and this wouldn't be reached in case of undefined because of the equality check below\n\t\tif (is_option_element && key === 'value' && value == null) {\n\t\t\t// The <option> element is a special case because removing the value attribute means\n\t\t\t// the value is set to the text content of the option element, and setting the value\n\t\t\t// to null or undefined means the value is set to the string \"null\" or \"undefined\".\n\t\t\t// To align with how we handle this case in non-spread-scenarios, this logic is needed.\n\t\t\t// There's a super-edge-case bug here that is left in in favor of smaller code size:\n\t\t\t// Because of the \"set missing props to null\" logic above, we can't differentiate\n\t\t\t// between a missing value and an explicitly set value of null or undefined. That means\n\t\t\t// that once set, the value attribute of an <option> element can't be removed. This is\n\t\t\t// a very rare edge case, and removing the attribute altogether isn't possible either\n\t\t\t// for the <option value={undefined}> case, so we're not losing any functionality here.\n\t\t\t// @ts-ignore\n\t\t\telement.value = element.__value = '';\n\t\t\tcurrent[key] = value;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key === 'class') {\n\t\t\tvar is_html = element.namespaceURI === 'http://www.w3.org/1999/xhtml';\n\t\t\tset_class(element, is_html, value, css_hash, prev?.[CLASS], next[CLASS]);\n\t\t\tcurrent[key] = value;\n\t\t\tcurrent[CLASS] = next[CLASS];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key === 'style') {\n\t\t\tset_style(element, value, prev?.[STYLE], next[STYLE]);\n\t\t\tcurrent[key] = value;\n\t\t\tcurrent[STYLE] = next[STYLE];\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar prev_value = current[key];\n\t\tif (value === prev_value) continue;\n\n\t\tcurrent[key] = value;\n\n\t\tvar prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)\n\t\tif (prefix === '$$') continue;\n\n\t\tif (prefix === 'on') {\n\t\t\t/** @type {{ capture?: true }} */\n\t\t\tconst opts = {};\n\t\t\tconst event_handle_key = '$$' + key;\n\t\t\tlet event_name = key.slice(2);\n\t\t\tvar delegated = is_delegated(event_name);\n\n\t\t\tif (is_capture_event(event_name)) {\n\t\t\t\tevent_name = event_name.slice(0, -7);\n\t\t\t\topts.capture = true;\n\t\t\t}\n\n\t\t\tif (!delegated && prev_value) {\n\t\t\t\t// Listening to same event but different handler -> our handle function below takes care of this\n\t\t\t\t// If we were to remove and add listeners in this case, it could happen that the event is \"swallowed\"\n\t\t\t\t// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler\n\t\t\t\t// https://github.com/sveltejs/svelte/issues/11903\n\t\t\t\tif (value != null) continue;\n\n\t\t\t\telement.removeEventListener(event_name, current[event_handle_key], opts);\n\t\t\t\tcurrent[event_handle_key] = null;\n\t\t\t}\n\n\t\t\tif (value != null) {\n\t\t\t\tif (!delegated) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @this {any}\n\t\t\t\t\t * @param {Event} evt\n\t\t\t\t\t */\n\t\t\t\t\tfunction handle(evt) {\n\t\t\t\t\t\tcurrent[key].call(this, evt);\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrent[event_handle_key] = create_event(event_name, element, handle, opts);\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\telement[`__${event_name}`] = value;\n\t\t\t\t\tdelegate([event_name]);\n\t\t\t\t}\n\t\t\t} else if (delegated) {\n\t\t\t\t// @ts-ignore\n\t\t\t\telement[`__${event_name}`] = undefined;\n\t\t\t}\n\t\t} else if (key === 'style') {\n\t\t\t// avoid using the setter\n\t\t\tset_attribute(element, key, value);\n\t\t} else if (key === 'autofocus') {\n\t\t\tautofocus(/** @type {HTMLElement} */ (element), Boolean(value));\n\t\t} else if (!is_custom_element && (key === '__value' || (key === 'value' && value != null))) {\n\t\t\t// @ts-ignore We're not running this for custom elements because __value is actually\n\t\t\t// how Lit stores the current value on the element, and messing with that would break things.\n\t\t\telement.value = element.__value = value;\n\t\t} else if (key === 'selected' && is_option_element) {\n\t\t\tset_selected(/** @type {HTMLOptionElement} */ (element), value);\n\t\t} else {\n\t\t\tvar name = key;\n\t\t\tif (!preserve_attribute_case) {\n\t\t\t\tname = normalize_attribute(name);\n\t\t\t}\n\n\t\t\tvar is_default = name === 'defaultValue' || name === 'defaultChecked';\n\n\t\t\tif (value == null && !is_custom_element && !is_default) {\n\t\t\t\tattributes[key] = null;\n\n\t\t\t\tif (name === 'value' || name === 'checked') {\n\t\t\t\t\t// removing value/checked also removes defaultValue/defaultChecked â€” preserve\n\t\t\t\t\tlet input = /** @type {HTMLInputElement} */ (element);\n\t\t\t\t\tconst use_default = prev === undefined;\n\t\t\t\t\tif (name === 'value') {\n\t\t\t\t\t\tlet previous = input.defaultValue;\n\t\t\t\t\t\tinput.removeAttribute(name);\n\t\t\t\t\t\tinput.defaultValue = previous;\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tinput.value = input.__value = use_default ? previous : null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet previous = input.defaultChecked;\n\t\t\t\t\t\tinput.removeAttribute(name);\n\t\t\t\t\t\tinput.defaultChecked = previous;\n\t\t\t\t\t\tinput.checked = use_default ? previous : false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telement.removeAttribute(key);\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\tis_default ||\n\t\t\t\t(setters.includes(name) && (is_custom_element || typeof value !== 'string'))\n\t\t\t) {\n\t\t\t\t// @ts-ignore\n\t\t\t\telement[name] = value;\n\t\t\t} else if (typeof value !== 'function') {\n\t\t\t\tset_attribute(element, name, value, skip_warning);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_hydrating_custom_element) {\n\t\tset_hydrating(true);\n\t}\n\n\treturn current;\n}\n\n/**\n *\n * @param {Element} element\n */\nfunction get_attributes(element) {\n\treturn /** @type {Record<string | symbol, unknown>} **/ (\n\t\t// @ts-expect-error\n\t\telement.__attributes ??= {\n\t\t\t[IS_CUSTOM_ELEMENT]: element.nodeName.includes('-'),\n\t\t\t[IS_HTML]: element.namespaceURI === NAMESPACE_HTML\n\t\t}\n\t);\n}\n\n/** @type {Map<string, string[]>} */\nvar setters_cache = new Map();\n\n/** @param {Element} element */\nfunction get_setters(element) {\n\tvar setters = setters_cache.get(element.nodeName);\n\tif (setters) return setters;\n\tsetters_cache.set(element.nodeName, (setters = []));\n\n\tvar descriptors;\n\tvar proto = element; // In the case of custom elements there might be setters on the instance\n\tvar element_proto = Element.prototype;\n\n\t// Stop at Element, from there on there's only unnecessary setters we're not interested in\n\t// Do not use contructor.name here as that's unreliable in some browser environments\n\twhile (element_proto !== proto) {\n\t\tdescriptors = get_descriptors(proto);\n\n\t\tfor (var key in descriptors) {\n\t\t\tif (descriptors[key].set) {\n\t\t\t\tsetters.push(key);\n\t\t\t}\n\t\t}\n\n\t\tproto = get_prototype_of(proto);\n\t}\n\n\treturn setters;\n}\n\n/**\n * @param {any} element\n * @param {string} attribute\n * @param {string} value\n */\nfunction check_src_in_dev_hydration(element, attribute, value) {\n\tif (!DEV) return;\n\tif (attribute === 'srcset' && srcset_url_equal(element, value)) return;\n\tif (src_url_equal(element.getAttribute(attribute) ?? '', value)) return;\n\n\tw.hydration_attribute_changed(\n\t\tattribute,\n\t\telement.outerHTML.replace(element.innerHTML, element.innerHTML && '...'),\n\t\tString(value)\n\t);\n}\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nfunction src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\treturn new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element\n * @param {string} srcset\n * @returns {boolean}\n */\nfunction srcset_url_equal(element, srcset) {\n\tvar element_urls = split_srcset(element.srcset);\n\tvar urls = split_srcset(srcset);\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n"],"names":["update_styles","dom","prev","next","priority","key","value","set_style","prev_styles","next_styles","hydrating","next_style_attr","to_style","CLASS","STYLE","IS_CUSTOM_ELEMENT","IS_HTML","remove_input_defaults","input","already_removed","remove_defaults","set_attribute","checked","queue_idle_task","add_form_reset_listener","set_value","element","attributes","get_attributes","set_checked","set_selected","selected","attribute","skip_warning","LOADING_ATTR_SYMBOL","get_setters","set_attributes","css_hash","is_custom_element","preserve_attribute_case","is_hydrating_custom_element","set_hydrating","current","is_option_element","clsx","_a","setters","is_html","set_class","prev_value","prefix","opts","event_handle_key","event_name","delegated","is_delegated","is_capture_event","delegate","handle","evt","create_event","autofocus","name","normalize_attribute","is_default","use_default","previous","NAMESPACE_HTML","setters_cache","descriptors","proto","element_proto","get_descriptors","get_prototype_of"],"mappings":"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","x_google_ignoreList":[0,1]}