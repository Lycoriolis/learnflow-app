{"version":3,"mappings":"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","names":["name","version","registerVersion","PENDING_TIMEOUT_MS","PACKAGE_VERSION","INTERNAL_AUTH_VERSION","INSTALLATIONS_API_URL","TOKEN_EXPIRATION_BUFFER","SERVICE","SERVICE_NAME","ERROR_DESCRIPTION_MAP","ERROR_FACTORY","ErrorFactory","isServerError","error","FirebaseError","getInstallationsEndpoint","projectId","extractAuthTokenInfoFromResponse","response","getExpiresInFromResponseExpiresIn","getErrorFromResponse","requestName","__async","errorData","getHeaders","apiKey","getHeadersWithAuth","appConfig","refreshToken","headers","getAuthorizationHeader","retryIfServerError","fn","result","responseExpiresIn","createInstallationRequest","_0","_1","heartbeatServiceProvider","fid","endpoint","heartbeatService","heartbeatsHeader","body","request","responseValue","sleep","ms","resolve","bufferToBase64UrlSafe","array","VALID_FID_PATTERN","INVALID_FID","generateFid","fidByteArray","encode","_a","getKey","fidChangeCallbacks","fidChanged","key","callFidChangeCallbacks","broadcastFidChange","callbacks","callback","channel","getBroadcastChannel","closeBroadcastChannel","broadcastChannel","DATABASE_NAME","DATABASE_VERSION","OBJECT_STORE_NAME","dbPromise","getDbPromise","openDB","db","oldVersion","set","value","tx","objectStore","oldValue","remove","update","updateFn","store","newValue","getInstallationEntry","installations","registrationPromise","installationEntry","oldEntry","updateOrCreateInstallationEntry","entryWithPromise","triggerRegistrationIfNecessary","entry","clearTimedOutRequest","registrationPromiseWithError","inProgressEntry","registerInstallation","waitUntilFidRegistration","registeredInstallationEntry","e","updateInstallationRequest","hasInstallationRequestTimedOut","generateAuthTokenRequest","getGenerateAuthTokenEndpoint","refreshAuthToken","forceRefresh","tokenPromise","isEntryRegistered","oldAuthToken","isAuthTokenValid","waitUntilAuthTokenRequest","makeAuthTokenRequestInProgressEntry","fetchAuthTokenFromServer","updateAuthTokenRequest","authToken","hasAuthTokenRequestTimedOut","updatedInstallationEntry","isAuthTokenExpired","now","inProgressAuthToken","getId","installationsImpl","getToken","completeInstallationRegistration","extractAppConfig","app","getMissingValueError","configKeys","keyName","valueName","INSTALLATIONS_NAME","INSTALLATIONS_NAME_INTERNAL","publicFactory","container","_getProvider","internalFactory","registerInstallations","_registerComponent","Component","ANALYTICS_TYPE","GA_FID_KEY","ORIGIN_KEY","FETCH_TIMEOUT_MILLIS","DYNAMIC_CONFIG_URL","GTAG_URL","logger","Logger","ERRORS","createGtagTrustedTypesScriptURL","url","err","promiseAllSettled","promises","promise","createTrustedTypesPolicy","policyName","policyOptions","trustedTypesPolicy","insertScriptTag","dataLayerName","measurementId","script","gtagScriptURL","getOrCreateDataLayer","dataLayer","gtagOnConfig","gtagCore","initializationPromisesMap","dynamicConfigPromisesList","measurementIdToAppId","gtagParams","correspondingAppId","foundConfig","config","gtagOnEvent","initializationPromisesToWaitFor","gaSendToList","dynamicConfigResults","sendToId","initializationPromise","wrapGtag","gtagWrapper","command","args","consentAction","fieldName","customParams","wrapOrCreateGtag","gtagFunctionName","_args","findGtagScriptOnPage","scriptTags","tag","LONG_RETRY_FACTOR","BASE_INTERVAL_MILLIS","RetryData","throttleMetadata","intervalMillis","appId","metadata","defaultRetryData","fetchDynamicConfig","appFields","appUrl","errorMessage","jsonResponse","_ignored","fetchDynamicConfigWithRetry","retryData","timeoutMillis","signal","AnalyticsAbortSignal","attemptFetchDynamicConfigWithRetry","_2","throttleEndTimeMillis","backoffCount","setAbortableTimeout","isRetriableError","backoffMillis","calculateBackoffMillis","reject","timeout","httpStatus","listener","logEvent$1","gtagFunction","eventName","eventParams","options","params","validateIndexedDB","isIndexedDBAvailable","validateIndexedDBOpenable","_initializeAnalytics","dynamicConfigPromise","fidPromise","envIsValid","dynamicConfig","configProperties","AnalyticsService","gtagName","gtagCoreFunction","wrappedGtagFunction","globalInitDone","warnOnBrowserContextMismatch","mismatchedEnvMessages","isBrowserExtension","areCookiesEnabled","details","message","index","factory","wrappedGtag","getAnalytics","getApp","getModularInstance","analyticsProvider","initializeAnalytics","existingInstance","deepEqual","logEvent","analyticsInstance","registerAnalytics","analyticsOptions","analytics","firebaseConfig","isDev","logDebug","data","auth","initializeApp","getAuth","getFirestore","UserServiceError","code","originalError","getUserProfile","uid","doc","getDoc","__vitePreload","firebase","ref","snap","errorCode","createUserProfile","profile","setDoc","updateUserProfile","updateDoc","userProfile","writable","userProfileLoading","userProfileError","loadUserProfile","email","displayName","updateUserProfileService","authInitialized","initAuth","loading","onAuthStateChanged","userData","isAuthenticated","user","authError","setAuthPersistence","rememberMe","setPersistence","browserLocalPersistence","browserSessionPersistence","formatAuthError","errorMap","register","password","userCredential","createUserWithEmailAndPassword","updateProfile","formattedError","login","signInWithEmailAndPassword","loginWithGoogle","provider","GoogleAuthProvider","signInWithPopup","logout","firebaseSignOut","resetPassword","sendPasswordResetEmail","getCurrentUser","currentUser","isAdmin","derived","$user","firebaseLogout"],"ignoreList":[0,1,2],"sources":["../../../../../../node_modules/firebase/app/dist/esm/index.esm.js","../../../../../../node_modules/@firebase/installations/dist/esm/index.esm2017.js","../../../../../../node_modules/@firebase/analytics/dist/esm/index.esm2017.js","../../../../../../src/lib/firebase.ts","../../../../../../src/lib/services/userService.ts","../../../../../../src/lib/stores/userProfileStore.ts","../../../../../../src/lib/authService.ts","../../../../../../src/lib/stores/authStore.ts"],"sourcesContent":["import { registerVersion } from '@firebase/app';\nexport * from '@firebase/app';\n\nvar name = \"firebase\";\nvar version = \"10.14.1\";\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nregisterVersion(name, version, 'app');\n//# sourceMappingURL=index.esm.js.map\n","import { _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';\nimport { Component } from '@firebase/component';\nimport { ErrorFactory, FirebaseError } from '@firebase/util';\nimport { openDB } from 'idb';\n\nconst name = \"@firebase/installations\";\nconst version = \"0.6.9\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst PENDING_TIMEOUT_MS = 10000;\r\nconst PACKAGE_VERSION = `w:${version}`;\r\nconst INTERNAL_AUTH_VERSION = 'FIS_v2';\r\nconst INSTALLATIONS_API_URL = 'https://firebaseinstallations.googleapis.com/v1';\r\nconst TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour\r\nconst SERVICE = 'installations';\r\nconst SERVICE_NAME = 'Installations';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERROR_DESCRIPTION_MAP = {\r\n    [\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */]: 'Missing App configuration value: \"{$valueName}\"',\r\n    [\"not-registered\" /* ErrorCode.NOT_REGISTERED */]: 'Firebase Installation is not registered.',\r\n    [\"installation-not-found\" /* ErrorCode.INSTALLATION_NOT_FOUND */]: 'Firebase Installation not found.',\r\n    [\"request-failed\" /* ErrorCode.REQUEST_FAILED */]: '{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',\r\n    [\"app-offline\" /* ErrorCode.APP_OFFLINE */]: 'Could not process request. Application offline.',\r\n    [\"delete-pending-registration\" /* ErrorCode.DELETE_PENDING_REGISTRATION */]: \"Can't delete installation while there is a pending registration request.\"\r\n};\r\nconst ERROR_FACTORY = new ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);\r\n/** Returns true if error is a FirebaseError that is based on an error from the server. */\r\nfunction isServerError(error) {\r\n    return (error instanceof FirebaseError &&\r\n        error.code.includes(\"request-failed\" /* ErrorCode.REQUEST_FAILED */));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction getInstallationsEndpoint({ projectId }) {\r\n    return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;\r\n}\r\nfunction extractAuthTokenInfoFromResponse(response) {\r\n    return {\r\n        token: response.token,\r\n        requestStatus: 2 /* RequestStatus.COMPLETED */,\r\n        expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),\r\n        creationTime: Date.now()\r\n    };\r\n}\r\nasync function getErrorFromResponse(requestName, response) {\r\n    const responseJson = await response.json();\r\n    const errorData = responseJson.error;\r\n    return ERROR_FACTORY.create(\"request-failed\" /* ErrorCode.REQUEST_FAILED */, {\r\n        requestName,\r\n        serverCode: errorData.code,\r\n        serverMessage: errorData.message,\r\n        serverStatus: errorData.status\r\n    });\r\n}\r\nfunction getHeaders({ apiKey }) {\r\n    return new Headers({\r\n        'Content-Type': 'application/json',\r\n        Accept: 'application/json',\r\n        'x-goog-api-key': apiKey\r\n    });\r\n}\r\nfunction getHeadersWithAuth(appConfig, { refreshToken }) {\r\n    const headers = getHeaders(appConfig);\r\n    headers.append('Authorization', getAuthorizationHeader(refreshToken));\r\n    return headers;\r\n}\r\n/**\r\n * Calls the passed in fetch wrapper and returns the response.\r\n * If the returned response has a status of 5xx, re-runs the function once and\r\n * returns the response.\r\n */\r\nasync function retryIfServerError(fn) {\r\n    const result = await fn();\r\n    if (result.status >= 500 && result.status < 600) {\r\n        // Internal Server Error. Retry request.\r\n        return fn();\r\n    }\r\n    return result;\r\n}\r\nfunction getExpiresInFromResponseExpiresIn(responseExpiresIn) {\r\n    // This works because the server will never respond with fractions of a second.\r\n    return Number(responseExpiresIn.replace('s', '000'));\r\n}\r\nfunction getAuthorizationHeader(refreshToken) {\r\n    return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function createInstallationRequest({ appConfig, heartbeatServiceProvider }, { fid }) {\r\n    const endpoint = getInstallationsEndpoint(appConfig);\r\n    const headers = getHeaders(appConfig);\r\n    // If heartbeat service exists, add the heartbeat string to the header.\r\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\r\n        optional: true\r\n    });\r\n    if (heartbeatService) {\r\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\r\n        if (heartbeatsHeader) {\r\n            headers.append('x-firebase-client', heartbeatsHeader);\r\n        }\r\n    }\r\n    const body = {\r\n        fid,\r\n        authVersion: INTERNAL_AUTH_VERSION,\r\n        appId: appConfig.appId,\r\n        sdkVersion: PACKAGE_VERSION\r\n    };\r\n    const request = {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body)\r\n    };\r\n    const response = await retryIfServerError(() => fetch(endpoint, request));\r\n    if (response.ok) {\r\n        const responseValue = await response.json();\r\n        const registeredInstallationEntry = {\r\n            fid: responseValue.fid || fid,\r\n            registrationStatus: 2 /* RequestStatus.COMPLETED */,\r\n            refreshToken: responseValue.refreshToken,\r\n            authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)\r\n        };\r\n        return registeredInstallationEntry;\r\n    }\r\n    else {\r\n        throw await getErrorFromResponse('Create Installation', response);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Returns a promise that resolves after given time passes. */\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => {\r\n        setTimeout(resolve, ms);\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction bufferToBase64UrlSafe(array) {\r\n    const b64 = btoa(String.fromCharCode(...array));\r\n    return b64.replace(/\\+/g, '-').replace(/\\//g, '_');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst VALID_FID_PATTERN = /^[cdef][\\w-]{21}$/;\r\nconst INVALID_FID = '';\r\n/**\r\n * Generates a new FID using random values from Web Crypto API.\r\n * Returns an empty string if FID generation fails for any reason.\r\n */\r\nfunction generateFid() {\r\n    try {\r\n        // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5\r\n        // bytes. our implementation generates a 17 byte array instead.\r\n        const fidByteArray = new Uint8Array(17);\r\n        const crypto = self.crypto || self.msCrypto;\r\n        crypto.getRandomValues(fidByteArray);\r\n        // Replace the first 4 random bits with the constant FID header of 0b0111.\r\n        fidByteArray[0] = 0b01110000 + (fidByteArray[0] % 0b00010000);\r\n        const fid = encode(fidByteArray);\r\n        return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;\r\n    }\r\n    catch (_a) {\r\n        // FID generation errored\r\n        return INVALID_FID;\r\n    }\r\n}\r\n/** Converts a FID Uint8Array to a base64 string representation. */\r\nfunction encode(fidByteArray) {\r\n    const b64String = bufferToBase64UrlSafe(fidByteArray);\r\n    // Remove the 23rd character that was added because of the extra 4 bits at the\r\n    // end of our 17 byte array, and the '=' padding.\r\n    return b64String.substr(0, 22);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Returns a string key that can be used to identify the app. */\r\nfunction getKey(appConfig) {\r\n    return `${appConfig.appName}!${appConfig.appId}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst fidChangeCallbacks = new Map();\r\n/**\r\n * Calls the onIdChange callbacks with the new FID value, and broadcasts the\r\n * change to other tabs.\r\n */\r\nfunction fidChanged(appConfig, fid) {\r\n    const key = getKey(appConfig);\r\n    callFidChangeCallbacks(key, fid);\r\n    broadcastFidChange(key, fid);\r\n}\r\nfunction addCallback(appConfig, callback) {\r\n    // Open the broadcast channel if it's not already open,\r\n    // to be able to listen to change events from other tabs.\r\n    getBroadcastChannel();\r\n    const key = getKey(appConfig);\r\n    let callbackSet = fidChangeCallbacks.get(key);\r\n    if (!callbackSet) {\r\n        callbackSet = new Set();\r\n        fidChangeCallbacks.set(key, callbackSet);\r\n    }\r\n    callbackSet.add(callback);\r\n}\r\nfunction removeCallback(appConfig, callback) {\r\n    const key = getKey(appConfig);\r\n    const callbackSet = fidChangeCallbacks.get(key);\r\n    if (!callbackSet) {\r\n        return;\r\n    }\r\n    callbackSet.delete(callback);\r\n    if (callbackSet.size === 0) {\r\n        fidChangeCallbacks.delete(key);\r\n    }\r\n    // Close broadcast channel if there are no more callbacks.\r\n    closeBroadcastChannel();\r\n}\r\nfunction callFidChangeCallbacks(key, fid) {\r\n    const callbacks = fidChangeCallbacks.get(key);\r\n    if (!callbacks) {\r\n        return;\r\n    }\r\n    for (const callback of callbacks) {\r\n        callback(fid);\r\n    }\r\n}\r\nfunction broadcastFidChange(key, fid) {\r\n    const channel = getBroadcastChannel();\r\n    if (channel) {\r\n        channel.postMessage({ key, fid });\r\n    }\r\n    closeBroadcastChannel();\r\n}\r\nlet broadcastChannel = null;\r\n/** Opens and returns a BroadcastChannel if it is supported by the browser. */\r\nfunction getBroadcastChannel() {\r\n    if (!broadcastChannel && 'BroadcastChannel' in self) {\r\n        broadcastChannel = new BroadcastChannel('[Firebase] FID Change');\r\n        broadcastChannel.onmessage = e => {\r\n            callFidChangeCallbacks(e.data.key, e.data.fid);\r\n        };\r\n    }\r\n    return broadcastChannel;\r\n}\r\nfunction closeBroadcastChannel() {\r\n    if (fidChangeCallbacks.size === 0 && broadcastChannel) {\r\n        broadcastChannel.close();\r\n        broadcastChannel = null;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DATABASE_NAME = 'firebase-installations-database';\r\nconst DATABASE_VERSION = 1;\r\nconst OBJECT_STORE_NAME = 'firebase-installations-store';\r\nlet dbPromise = null;\r\nfunction getDbPromise() {\r\n    if (!dbPromise) {\r\n        dbPromise = openDB(DATABASE_NAME, DATABASE_VERSION, {\r\n            upgrade: (db, oldVersion) => {\r\n                // We don't use 'break' in this switch statement, the fall-through\r\n                // behavior is what we want, because if there are multiple versions between\r\n                // the old version and the current version, we want ALL the migrations\r\n                // that correspond to those versions to run, not only the last one.\r\n                // eslint-disable-next-line default-case\r\n                switch (oldVersion) {\r\n                    case 0:\r\n                        db.createObjectStore(OBJECT_STORE_NAME);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return dbPromise;\r\n}\r\n/** Assigns or overwrites the record for the given key with the given value. */\r\nasync function set(appConfig, value) {\r\n    const key = getKey(appConfig);\r\n    const db = await getDbPromise();\r\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n    const objectStore = tx.objectStore(OBJECT_STORE_NAME);\r\n    const oldValue = (await objectStore.get(key));\r\n    await objectStore.put(value, key);\r\n    await tx.done;\r\n    if (!oldValue || oldValue.fid !== value.fid) {\r\n        fidChanged(appConfig, value.fid);\r\n    }\r\n    return value;\r\n}\r\n/** Removes record(s) from the objectStore that match the given key. */\r\nasync function remove(appConfig) {\r\n    const key = getKey(appConfig);\r\n    const db = await getDbPromise();\r\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n    await tx.objectStore(OBJECT_STORE_NAME).delete(key);\r\n    await tx.done;\r\n}\r\n/**\r\n * Atomically updates a record with the result of updateFn, which gets\r\n * called with the current value. If newValue is undefined, the record is\r\n * deleted instead.\r\n * @return Updated value\r\n */\r\nasync function update(appConfig, updateFn) {\r\n    const key = getKey(appConfig);\r\n    const db = await getDbPromise();\r\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n    const store = tx.objectStore(OBJECT_STORE_NAME);\r\n    const oldValue = (await store.get(key));\r\n    const newValue = updateFn(oldValue);\r\n    if (newValue === undefined) {\r\n        await store.delete(key);\r\n    }\r\n    else {\r\n        await store.put(newValue, key);\r\n    }\r\n    await tx.done;\r\n    if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {\r\n        fidChanged(appConfig, newValue.fid);\r\n    }\r\n    return newValue;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Updates and returns the InstallationEntry from the database.\r\n * Also triggers a registration request if it is necessary and possible.\r\n */\r\nasync function getInstallationEntry(installations) {\r\n    let registrationPromise;\r\n    const installationEntry = await update(installations.appConfig, oldEntry => {\r\n        const installationEntry = updateOrCreateInstallationEntry(oldEntry);\r\n        const entryWithPromise = triggerRegistrationIfNecessary(installations, installationEntry);\r\n        registrationPromise = entryWithPromise.registrationPromise;\r\n        return entryWithPromise.installationEntry;\r\n    });\r\n    if (installationEntry.fid === INVALID_FID) {\r\n        // FID generation failed. Waiting for the FID from the server.\r\n        return { installationEntry: await registrationPromise };\r\n    }\r\n    return {\r\n        installationEntry,\r\n        registrationPromise\r\n    };\r\n}\r\n/**\r\n * Creates a new Installation Entry if one does not exist.\r\n * Also clears timed out pending requests.\r\n */\r\nfunction updateOrCreateInstallationEntry(oldEntry) {\r\n    const entry = oldEntry || {\r\n        fid: generateFid(),\r\n        registrationStatus: 0 /* RequestStatus.NOT_STARTED */\r\n    };\r\n    return clearTimedOutRequest(entry);\r\n}\r\n/**\r\n * If the Firebase Installation is not registered yet, this will trigger the\r\n * registration and return an InProgressInstallationEntry.\r\n *\r\n * If registrationPromise does not exist, the installationEntry is guaranteed\r\n * to be registered.\r\n */\r\nfunction triggerRegistrationIfNecessary(installations, installationEntry) {\r\n    if (installationEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n        if (!navigator.onLine) {\r\n            // Registration required but app is offline.\r\n            const registrationPromiseWithError = Promise.reject(ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */));\r\n            return {\r\n                installationEntry,\r\n                registrationPromise: registrationPromiseWithError\r\n            };\r\n        }\r\n        // Try registering. Change status to IN_PROGRESS.\r\n        const inProgressEntry = {\r\n            fid: installationEntry.fid,\r\n            registrationStatus: 1 /* RequestStatus.IN_PROGRESS */,\r\n            registrationTime: Date.now()\r\n        };\r\n        const registrationPromise = registerInstallation(installations, inProgressEntry);\r\n        return { installationEntry: inProgressEntry, registrationPromise };\r\n    }\r\n    else if (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n        return {\r\n            installationEntry,\r\n            registrationPromise: waitUntilFidRegistration(installations)\r\n        };\r\n    }\r\n    else {\r\n        return { installationEntry };\r\n    }\r\n}\r\n/** This will be executed only once for each new Firebase Installation. */\r\nasync function registerInstallation(installations, installationEntry) {\r\n    try {\r\n        const registeredInstallationEntry = await createInstallationRequest(installations, installationEntry);\r\n        return set(installations.appConfig, registeredInstallationEntry);\r\n    }\r\n    catch (e) {\r\n        if (isServerError(e) && e.customData.serverCode === 409) {\r\n            // Server returned a \"FID cannot be used\" error.\r\n            // Generate a new ID next time.\r\n            await remove(installations.appConfig);\r\n        }\r\n        else {\r\n            // Registration failed. Set FID as not registered.\r\n            await set(installations.appConfig, {\r\n                fid: installationEntry.fid,\r\n                registrationStatus: 0 /* RequestStatus.NOT_STARTED */\r\n            });\r\n        }\r\n        throw e;\r\n    }\r\n}\r\n/** Call if FID registration is pending in another request. */\r\nasync function waitUntilFidRegistration(installations) {\r\n    // Unfortunately, there is no way of reliably observing when a value in\r\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\r\n    // so we need to poll.\r\n    let entry = await updateInstallationRequest(installations.appConfig);\r\n    while (entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n        // createInstallation request still in progress.\r\n        await sleep(100);\r\n        entry = await updateInstallationRequest(installations.appConfig);\r\n    }\r\n    if (entry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n        // The request timed out or failed in a different call. Try again.\r\n        const { installationEntry, registrationPromise } = await getInstallationEntry(installations);\r\n        if (registrationPromise) {\r\n            return registrationPromise;\r\n        }\r\n        else {\r\n            // if there is no registrationPromise, entry is registered.\r\n            return installationEntry;\r\n        }\r\n    }\r\n    return entry;\r\n}\r\n/**\r\n * Called only if there is a CreateInstallation request in progress.\r\n *\r\n * Updates the InstallationEntry in the DB based on the status of the\r\n * CreateInstallation request.\r\n *\r\n * Returns the updated InstallationEntry.\r\n */\r\nfunction updateInstallationRequest(appConfig) {\r\n    return update(appConfig, oldEntry => {\r\n        if (!oldEntry) {\r\n            throw ERROR_FACTORY.create(\"installation-not-found\" /* ErrorCode.INSTALLATION_NOT_FOUND */);\r\n        }\r\n        return clearTimedOutRequest(oldEntry);\r\n    });\r\n}\r\nfunction clearTimedOutRequest(entry) {\r\n    if (hasInstallationRequestTimedOut(entry)) {\r\n        return {\r\n            fid: entry.fid,\r\n            registrationStatus: 0 /* RequestStatus.NOT_STARTED */\r\n        };\r\n    }\r\n    return entry;\r\n}\r\nfunction hasInstallationRequestTimedOut(installationEntry) {\r\n    return (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */ &&\r\n        installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now());\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function generateAuthTokenRequest({ appConfig, heartbeatServiceProvider }, installationEntry) {\r\n    const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);\r\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\r\n    // If heartbeat service exists, add the heartbeat string to the header.\r\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\r\n        optional: true\r\n    });\r\n    if (heartbeatService) {\r\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\r\n        if (heartbeatsHeader) {\r\n            headers.append('x-firebase-client', heartbeatsHeader);\r\n        }\r\n    }\r\n    const body = {\r\n        installation: {\r\n            sdkVersion: PACKAGE_VERSION,\r\n            appId: appConfig.appId\r\n        }\r\n    };\r\n    const request = {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body)\r\n    };\r\n    const response = await retryIfServerError(() => fetch(endpoint, request));\r\n    if (response.ok) {\r\n        const responseValue = await response.json();\r\n        const completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);\r\n        return completedAuthToken;\r\n    }\r\n    else {\r\n        throw await getErrorFromResponse('Generate Auth Token', response);\r\n    }\r\n}\r\nfunction getGenerateAuthTokenEndpoint(appConfig, { fid }) {\r\n    return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a valid authentication token for the installation. Generates a new\r\n * token if one doesn't exist, is expired or about to expire.\r\n *\r\n * Should only be called if the Firebase Installation is registered.\r\n */\r\nasync function refreshAuthToken(installations, forceRefresh = false) {\r\n    let tokenPromise;\r\n    const entry = await update(installations.appConfig, oldEntry => {\r\n        if (!isEntryRegistered(oldEntry)) {\r\n            throw ERROR_FACTORY.create(\"not-registered\" /* ErrorCode.NOT_REGISTERED */);\r\n        }\r\n        const oldAuthToken = oldEntry.authToken;\r\n        if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {\r\n            // There is a valid token in the DB.\r\n            return oldEntry;\r\n        }\r\n        else if (oldAuthToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n            // There already is a token request in progress.\r\n            tokenPromise = waitUntilAuthTokenRequest(installations, forceRefresh);\r\n            return oldEntry;\r\n        }\r\n        else {\r\n            // No token or token expired.\r\n            if (!navigator.onLine) {\r\n                throw ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */);\r\n            }\r\n            const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);\r\n            tokenPromise = fetchAuthTokenFromServer(installations, inProgressEntry);\r\n            return inProgressEntry;\r\n        }\r\n    });\r\n    const authToken = tokenPromise\r\n        ? await tokenPromise\r\n        : entry.authToken;\r\n    return authToken;\r\n}\r\n/**\r\n * Call only if FID is registered and Auth Token request is in progress.\r\n *\r\n * Waits until the current pending request finishes. If the request times out,\r\n * tries once in this thread as well.\r\n */\r\nasync function waitUntilAuthTokenRequest(installations, forceRefresh) {\r\n    // Unfortunately, there is no way of reliably observing when a value in\r\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\r\n    // so we need to poll.\r\n    let entry = await updateAuthTokenRequest(installations.appConfig);\r\n    while (entry.authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n        // generateAuthToken still in progress.\r\n        await sleep(100);\r\n        entry = await updateAuthTokenRequest(installations.appConfig);\r\n    }\r\n    const authToken = entry.authToken;\r\n    if (authToken.requestStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n        // The request timed out or failed in a different call. Try again.\r\n        return refreshAuthToken(installations, forceRefresh);\r\n    }\r\n    else {\r\n        return authToken;\r\n    }\r\n}\r\n/**\r\n * Called only if there is a GenerateAuthToken request in progress.\r\n *\r\n * Updates the InstallationEntry in the DB based on the status of the\r\n * GenerateAuthToken request.\r\n *\r\n * Returns the updated InstallationEntry.\r\n */\r\nfunction updateAuthTokenRequest(appConfig) {\r\n    return update(appConfig, oldEntry => {\r\n        if (!isEntryRegistered(oldEntry)) {\r\n            throw ERROR_FACTORY.create(\"not-registered\" /* ErrorCode.NOT_REGISTERED */);\r\n        }\r\n        const oldAuthToken = oldEntry.authToken;\r\n        if (hasAuthTokenRequestTimedOut(oldAuthToken)) {\r\n            return Object.assign(Object.assign({}, oldEntry), { authToken: { requestStatus: 0 /* RequestStatus.NOT_STARTED */ } });\r\n        }\r\n        return oldEntry;\r\n    });\r\n}\r\nasync function fetchAuthTokenFromServer(installations, installationEntry) {\r\n    try {\r\n        const authToken = await generateAuthTokenRequest(installations, installationEntry);\r\n        const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken });\r\n        await set(installations.appConfig, updatedInstallationEntry);\r\n        return authToken;\r\n    }\r\n    catch (e) {\r\n        if (isServerError(e) &&\r\n            (e.customData.serverCode === 401 || e.customData.serverCode === 404)) {\r\n            // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\r\n            // Generate a new ID next time.\r\n            await remove(installations.appConfig);\r\n        }\r\n        else {\r\n            const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken: { requestStatus: 0 /* RequestStatus.NOT_STARTED */ } });\r\n            await set(installations.appConfig, updatedInstallationEntry);\r\n        }\r\n        throw e;\r\n    }\r\n}\r\nfunction isEntryRegistered(installationEntry) {\r\n    return (installationEntry !== undefined &&\r\n        installationEntry.registrationStatus === 2 /* RequestStatus.COMPLETED */);\r\n}\r\nfunction isAuthTokenValid(authToken) {\r\n    return (authToken.requestStatus === 2 /* RequestStatus.COMPLETED */ &&\r\n        !isAuthTokenExpired(authToken));\r\n}\r\nfunction isAuthTokenExpired(authToken) {\r\n    const now = Date.now();\r\n    return (now < authToken.creationTime ||\r\n        authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER);\r\n}\r\n/** Returns an updated InstallationEntry with an InProgressAuthToken. */\r\nfunction makeAuthTokenRequestInProgressEntry(oldEntry) {\r\n    const inProgressAuthToken = {\r\n        requestStatus: 1 /* RequestStatus.IN_PROGRESS */,\r\n        requestTime: Date.now()\r\n    };\r\n    return Object.assign(Object.assign({}, oldEntry), { authToken: inProgressAuthToken });\r\n}\r\nfunction hasAuthTokenRequestTimedOut(authToken) {\r\n    return (authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */ &&\r\n        authToken.requestTime + PENDING_TIMEOUT_MS < Date.now());\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Creates a Firebase Installation if there isn't one for the app and\r\n * returns the Installation ID.\r\n * @param installations - The `Installations` instance.\r\n *\r\n * @public\r\n */\r\nasync function getId(installations) {\r\n    const installationsImpl = installations;\r\n    const { installationEntry, registrationPromise } = await getInstallationEntry(installationsImpl);\r\n    if (registrationPromise) {\r\n        registrationPromise.catch(console.error);\r\n    }\r\n    else {\r\n        // If the installation is already registered, update the authentication\r\n        // token if needed.\r\n        refreshAuthToken(installationsImpl).catch(console.error);\r\n    }\r\n    return installationEntry.fid;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a Firebase Installations auth token, identifying the current\r\n * Firebase Installation.\r\n * @param installations - The `Installations` instance.\r\n * @param forceRefresh - Force refresh regardless of token expiration.\r\n *\r\n * @public\r\n */\r\nasync function getToken(installations, forceRefresh = false) {\r\n    const installationsImpl = installations;\r\n    await completeInstallationRegistration(installationsImpl);\r\n    // At this point we either have a Registered Installation in the DB, or we've\r\n    // already thrown an error.\r\n    const authToken = await refreshAuthToken(installationsImpl, forceRefresh);\r\n    return authToken.token;\r\n}\r\nasync function completeInstallationRegistration(installations) {\r\n    const { registrationPromise } = await getInstallationEntry(installations);\r\n    if (registrationPromise) {\r\n        // A createInstallation request is in progress. Wait until it finishes.\r\n        await registrationPromise;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function deleteInstallationRequest(appConfig, installationEntry) {\r\n    const endpoint = getDeleteEndpoint(appConfig, installationEntry);\r\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\r\n    const request = {\r\n        method: 'DELETE',\r\n        headers\r\n    };\r\n    const response = await retryIfServerError(() => fetch(endpoint, request));\r\n    if (!response.ok) {\r\n        throw await getErrorFromResponse('Delete Installation', response);\r\n    }\r\n}\r\nfunction getDeleteEndpoint(appConfig, { fid }) {\r\n    return `${getInstallationsEndpoint(appConfig)}/${fid}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Deletes the Firebase Installation and all associated data.\r\n * @param installations - The `Installations` instance.\r\n *\r\n * @public\r\n */\r\nasync function deleteInstallations(installations) {\r\n    const { appConfig } = installations;\r\n    const entry = await update(appConfig, oldEntry => {\r\n        if (oldEntry && oldEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */) {\r\n            // Delete the unregistered entry without sending a deleteInstallation request.\r\n            return undefined;\r\n        }\r\n        return oldEntry;\r\n    });\r\n    if (entry) {\r\n        if (entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */) {\r\n            // Can't delete while trying to register.\r\n            throw ERROR_FACTORY.create(\"delete-pending-registration\" /* ErrorCode.DELETE_PENDING_REGISTRATION */);\r\n        }\r\n        else if (entry.registrationStatus === 2 /* RequestStatus.COMPLETED */) {\r\n            if (!navigator.onLine) {\r\n                throw ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */);\r\n            }\r\n            else {\r\n                await deleteInstallationRequest(appConfig, entry);\r\n                await remove(appConfig);\r\n            }\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Sets a new callback that will get called when Installation ID changes.\r\n * Returns an unsubscribe function that will remove the callback when called.\r\n * @param installations - The `Installations` instance.\r\n * @param callback - The callback function that is invoked when FID changes.\r\n * @returns A function that can be called to unsubscribe.\r\n *\r\n * @public\r\n */\r\nfunction onIdChange(installations, callback) {\r\n    const { appConfig } = installations;\r\n    addCallback(appConfig, callback);\r\n    return () => {\r\n        removeCallback(appConfig, callback);\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns an instance of {@link Installations} associated with the given\r\n * {@link @firebase/app#FirebaseApp} instance.\r\n * @param app - The {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * @public\r\n */\r\nfunction getInstallations(app = getApp()) {\r\n    const installationsImpl = _getProvider(app, 'installations').getImmediate();\r\n    return installationsImpl;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction extractAppConfig(app) {\r\n    if (!app || !app.options) {\r\n        throw getMissingValueError('App Configuration');\r\n    }\r\n    if (!app.name) {\r\n        throw getMissingValueError('App Name');\r\n    }\r\n    // Required app config keys\r\n    const configKeys = [\r\n        'projectId',\r\n        'apiKey',\r\n        'appId'\r\n    ];\r\n    for (const keyName of configKeys) {\r\n        if (!app.options[keyName]) {\r\n            throw getMissingValueError(keyName);\r\n        }\r\n    }\r\n    return {\r\n        appName: app.name,\r\n        projectId: app.options.projectId,\r\n        apiKey: app.options.apiKey,\r\n        appId: app.options.appId\r\n    };\r\n}\r\nfunction getMissingValueError(valueName) {\r\n    return ERROR_FACTORY.create(\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */, {\r\n        valueName\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst INSTALLATIONS_NAME = 'installations';\r\nconst INSTALLATIONS_NAME_INTERNAL = 'installations-internal';\r\nconst publicFactory = (container) => {\r\n    const app = container.getProvider('app').getImmediate();\r\n    // Throws if app isn't configured properly.\r\n    const appConfig = extractAppConfig(app);\r\n    const heartbeatServiceProvider = _getProvider(app, 'heartbeat');\r\n    const installationsImpl = {\r\n        app,\r\n        appConfig,\r\n        heartbeatServiceProvider,\r\n        _delete: () => Promise.resolve()\r\n    };\r\n    return installationsImpl;\r\n};\r\nconst internalFactory = (container) => {\r\n    const app = container.getProvider('app').getImmediate();\r\n    // Internal FIS instance relies on public FIS instance.\r\n    const installations = _getProvider(app, INSTALLATIONS_NAME).getImmediate();\r\n    const installationsInternal = {\r\n        getId: () => getId(installations),\r\n        getToken: (forceRefresh) => getToken(installations, forceRefresh)\r\n    };\r\n    return installationsInternal;\r\n};\r\nfunction registerInstallations() {\r\n    _registerComponent(new Component(INSTALLATIONS_NAME, publicFactory, \"PUBLIC\" /* ComponentType.PUBLIC */));\r\n    _registerComponent(new Component(INSTALLATIONS_NAME_INTERNAL, internalFactory, \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n}\n\n/**\r\n * The Firebase Installations Web SDK.\r\n * This SDK does not work in a Node.js environment.\r\n *\r\n * @packageDocumentation\r\n */\r\nregisterInstallations();\r\nregisterVersion(name, version);\r\n// BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\nregisterVersion(name, version, 'esm2017');\n\nexport { deleteInstallations, getId, getInstallations, getToken, onIdChange };\n//# sourceMappingURL=index.esm2017.js.map\n","import { _getProvider, getApp, _registerComponent, registerVersion } from '@firebase/app';\nimport { Logger } from '@firebase/logger';\nimport { ErrorFactory, calculateBackoffMillis, FirebaseError, isIndexedDBAvailable, validateIndexedDBOpenable, isBrowserExtension, areCookiesEnabled, getModularInstance, deepEqual } from '@firebase/util';\nimport { Component } from '@firebase/component';\nimport '@firebase/installations';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Type constant for Firebase Analytics.\r\n */\r\nconst ANALYTICS_TYPE = 'analytics';\r\n// Key to attach FID to in gtag params.\r\nconst GA_FID_KEY = 'firebase_id';\r\nconst ORIGIN_KEY = 'origin';\r\nconst FETCH_TIMEOUT_MILLIS = 60 * 1000;\r\nconst DYNAMIC_CONFIG_URL = 'https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig';\r\nconst GTAG_URL = 'https://www.googletagmanager.com/gtag/js';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logger = new Logger('@firebase/analytics');\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERRORS = {\r\n    [\"already-exists\" /* AnalyticsError.ALREADY_EXISTS */]: 'A Firebase Analytics instance with the appId {$id} ' +\r\n        ' already exists. ' +\r\n        'Only one Firebase Analytics instance can be created for each appId.',\r\n    [\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */]: 'initializeAnalytics() cannot be called again with different options than those ' +\r\n        'it was initially called with. It can be called again with the same options to ' +\r\n        'return the existing instance, or getAnalytics() can be used ' +\r\n        'to get a reference to the already-initialized instance.',\r\n    [\"already-initialized-settings\" /* AnalyticsError.ALREADY_INITIALIZED_SETTINGS */]: 'Firebase Analytics has already been initialized.' +\r\n        'settings() must be called before initializing any Analytics instance' +\r\n        'or it will have no effect.',\r\n    [\"interop-component-reg-failed\" /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */]: 'Firebase Analytics Interop Component failed to instantiate: {$reason}',\r\n    [\"invalid-analytics-context\" /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */]: 'Firebase Analytics is not supported in this environment. ' +\r\n        'Wrap initialization of analytics in analytics.isSupported() ' +\r\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\r\n    [\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */]: 'IndexedDB unavailable or restricted in this environment. ' +\r\n        'Wrap initialization of analytics in analytics.isSupported() ' +\r\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\r\n    [\"fetch-throttle\" /* AnalyticsError.FETCH_THROTTLE */]: 'The config fetch request timed out while in an exponential backoff state.' +\r\n        ' Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',\r\n    [\"config-fetch-failed\" /* AnalyticsError.CONFIG_FETCH_FAILED */]: 'Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}',\r\n    [\"no-api-key\" /* AnalyticsError.NO_API_KEY */]: 'The \"apiKey\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\r\n        'contain a valid API key.',\r\n    [\"no-app-id\" /* AnalyticsError.NO_APP_ID */]: 'The \"appId\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\r\n        'contain a valid app ID.',\r\n    [\"no-client-id\" /* AnalyticsError.NO_CLIENT_ID */]: 'The \"client_id\" field is empty.',\r\n    [\"invalid-gtag-resource\" /* AnalyticsError.INVALID_GTAG_RESOURCE */]: 'Trusted Types detected an invalid gtag resource: {$gtagURL}.'\r\n};\r\nconst ERROR_FACTORY = new ErrorFactory('analytics', 'Analytics', ERRORS);\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Verifies and creates a TrustedScriptURL.\r\n */\r\nfunction createGtagTrustedTypesScriptURL(url) {\r\n    if (!url.startsWith(GTAG_URL)) {\r\n        const err = ERROR_FACTORY.create(\"invalid-gtag-resource\" /* AnalyticsError.INVALID_GTAG_RESOURCE */, {\r\n            gtagURL: url\r\n        });\r\n        logger.warn(err.message);\r\n        return '';\r\n    }\r\n    return url;\r\n}\r\n/**\r\n * Makeshift polyfill for Promise.allSettled(). Resolves when all promises\r\n * have either resolved or rejected.\r\n *\r\n * @param promises Array of promises to wait for.\r\n */\r\nfunction promiseAllSettled(promises) {\r\n    return Promise.all(promises.map(promise => promise.catch(e => e)));\r\n}\r\n/**\r\n * Creates a TrustedTypePolicy object that implements the rules passed as policyOptions.\r\n *\r\n * @param policyName A string containing the name of the policy\r\n * @param policyOptions Object containing implementations of instance methods for TrustedTypesPolicy, see {@link https://developer.mozilla.org/en-US/docs/Web/API/TrustedTypePolicy#instance_methods\r\n * | the TrustedTypePolicy reference documentation}.\r\n */\r\nfunction createTrustedTypesPolicy(policyName, policyOptions) {\r\n    // Create a TrustedTypes policy that we can use for updating src\r\n    // properties\r\n    let trustedTypesPolicy;\r\n    if (window.trustedTypes) {\r\n        trustedTypesPolicy = window.trustedTypes.createPolicy(policyName, policyOptions);\r\n    }\r\n    return trustedTypesPolicy;\r\n}\r\n/**\r\n * Inserts gtag script tag into the page to asynchronously download gtag.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\r\nfunction insertScriptTag(dataLayerName, measurementId) {\r\n    const trustedTypesPolicy = createTrustedTypesPolicy('firebase-js-sdk-policy', {\r\n        createScriptURL: createGtagTrustedTypesScriptURL\r\n    });\r\n    const script = document.createElement('script');\r\n    // We are not providing an analyticsId in the URL because it would trigger a `page_view`\r\n    // without fid. We will initialize ga-id using gtag (config) command together with fid.\r\n    const gtagScriptURL = `${GTAG_URL}?l=${dataLayerName}&id=${measurementId}`;\r\n    script.src = trustedTypesPolicy\r\n        ? trustedTypesPolicy === null || trustedTypesPolicy === void 0 ? void 0 : trustedTypesPolicy.createScriptURL(gtagScriptURL)\r\n        : gtagScriptURL;\r\n    script.async = true;\r\n    document.head.appendChild(script);\r\n}\r\n/**\r\n * Get reference to, or create, global datalayer.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\r\nfunction getOrCreateDataLayer(dataLayerName) {\r\n    // Check for existing dataLayer and create if needed.\r\n    let dataLayer = [];\r\n    if (Array.isArray(window[dataLayerName])) {\r\n        dataLayer = window[dataLayerName];\r\n    }\r\n    else {\r\n        window[dataLayerName] = dataLayer;\r\n    }\r\n    return dataLayer;\r\n}\r\n/**\r\n * Wrapped gtag logic when gtag is called with 'config' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param measurementId GA Measurement ID to set config for.\r\n * @param gtagParams Gtag config params to set.\r\n */\r\nasync function gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams) {\r\n    // If config is already fetched, we know the appId and can use it to look up what FID promise we\r\n    /// are waiting for, and wait only on that one.\r\n    const correspondingAppId = measurementIdToAppId[measurementId];\r\n    try {\r\n        if (correspondingAppId) {\r\n            await initializationPromisesMap[correspondingAppId];\r\n        }\r\n        else {\r\n            // If config is not fetched yet, wait for all configs (we don't know which one we need) and\r\n            // find the appId (if any) corresponding to this measurementId. If there is one, wait on\r\n            // that appId's initialization promise. If there is none, promise resolves and gtag\r\n            // call goes through.\r\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\r\n            const foundConfig = dynamicConfigResults.find(config => config.measurementId === measurementId);\r\n            if (foundConfig) {\r\n                await initializationPromisesMap[foundConfig.appId];\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        logger.error(e);\r\n    }\r\n    gtagCore(\"config\" /* GtagCommand.CONFIG */, measurementId, gtagParams);\r\n}\r\n/**\r\n * Wrapped gtag logic when gtag is called with 'event' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementId GA Measurement ID to log event to.\r\n * @param gtagParams Params to log with this event.\r\n */\r\nasync function gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams) {\r\n    try {\r\n        let initializationPromisesToWaitFor = [];\r\n        // If there's a 'send_to' param, check if any ID specified matches\r\n        // an initializeIds() promise we are waiting for.\r\n        if (gtagParams && gtagParams['send_to']) {\r\n            let gaSendToList = gtagParams['send_to'];\r\n            // Make it an array if is isn't, so it can be dealt with the same way.\r\n            if (!Array.isArray(gaSendToList)) {\r\n                gaSendToList = [gaSendToList];\r\n            }\r\n            // Checking 'send_to' fields requires having all measurement ID results back from\r\n            // the dynamic config fetch.\r\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\r\n            for (const sendToId of gaSendToList) {\r\n                // Any fetched dynamic measurement ID that matches this 'send_to' ID\r\n                const foundConfig = dynamicConfigResults.find(config => config.measurementId === sendToId);\r\n                const initializationPromise = foundConfig && initializationPromisesMap[foundConfig.appId];\r\n                if (initializationPromise) {\r\n                    initializationPromisesToWaitFor.push(initializationPromise);\r\n                }\r\n                else {\r\n                    // Found an item in 'send_to' that is not associated\r\n                    // directly with an FID, possibly a group.  Empty this array,\r\n                    // exit the loop early, and let it get populated below.\r\n                    initializationPromisesToWaitFor = [];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // This will be unpopulated if there was no 'send_to' field , or\r\n        // if not all entries in the 'send_to' field could be mapped to\r\n        // a FID. In these cases, wait on all pending initialization promises.\r\n        if (initializationPromisesToWaitFor.length === 0) {\r\n            /* eslint-disable-next-line @typescript-eslint/no-floating-promises */\r\n            initializationPromisesToWaitFor = Object.values(initializationPromisesMap);\r\n        }\r\n        // Run core gtag function with args after all relevant initialization\r\n        // promises have been resolved.\r\n        await Promise.all(initializationPromisesToWaitFor);\r\n        // Workaround for http://b/141370449 - third argument cannot be undefined.\r\n        gtagCore(\"event\" /* GtagCommand.EVENT */, measurementId, gtagParams || {});\r\n    }\r\n    catch (e) {\r\n        logger.error(e);\r\n    }\r\n}\r\n/**\r\n * Wraps a standard gtag function with extra code to wait for completion of\r\n * relevant initialization promises before sending requests.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n */\r\nfunction wrapGtag(gtagCore, \r\n/**\r\n * Allows wrapped gtag calls to wait on whichever initialization promises are required,\r\n * depending on the contents of the gtag params' `send_to` field, if any.\r\n */\r\ninitializationPromisesMap, \r\n/**\r\n * Wrapped gtag calls sometimes require all dynamic config fetches to have returned\r\n * before determining what initialization promises (which include FIDs) to wait for.\r\n */\r\ndynamicConfigPromisesList, \r\n/**\r\n * Wrapped gtag config calls can narrow down which initialization promise (with FID)\r\n * to wait for if the measurementId is already fetched, by getting the corresponding appId,\r\n * which is the key for the initialization promises map.\r\n */\r\nmeasurementIdToAppId) {\r\n    /**\r\n     * Wrapper around gtag that ensures FID is sent with gtag calls.\r\n     * @param command Gtag command type.\r\n     * @param idOrNameOrParams Measurement ID if command is EVENT/CONFIG, params if command is SET.\r\n     * @param gtagParams Params if event is EVENT/CONFIG.\r\n     */\r\n    async function gtagWrapper(command, ...args) {\r\n        try {\r\n            // If event, check that relevant initialization promises have completed.\r\n            if (command === \"event\" /* GtagCommand.EVENT */) {\r\n                const [measurementId, gtagParams] = args;\r\n                // If EVENT, second arg must be measurementId.\r\n                await gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams);\r\n            }\r\n            else if (command === \"config\" /* GtagCommand.CONFIG */) {\r\n                const [measurementId, gtagParams] = args;\r\n                // If CONFIG, second arg must be measurementId.\r\n                await gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams);\r\n            }\r\n            else if (command === \"consent\" /* GtagCommand.CONSENT */) {\r\n                const [consentAction, gtagParams] = args;\r\n                // consentAction can be one of 'default' or 'update'.\r\n                gtagCore(\"consent\" /* GtagCommand.CONSENT */, consentAction, gtagParams);\r\n            }\r\n            else if (command === \"get\" /* GtagCommand.GET */) {\r\n                const [measurementId, fieldName, callback] = args;\r\n                gtagCore(\"get\" /* GtagCommand.GET */, measurementId, fieldName, callback);\r\n            }\r\n            else if (command === \"set\" /* GtagCommand.SET */) {\r\n                const [customParams] = args;\r\n                // If SET, second arg must be params.\r\n                gtagCore(\"set\" /* GtagCommand.SET */, customParams);\r\n            }\r\n            else {\r\n                gtagCore(command, ...args);\r\n            }\r\n        }\r\n        catch (e) {\r\n            logger.error(e);\r\n        }\r\n    }\r\n    return gtagWrapper;\r\n}\r\n/**\r\n * Creates global gtag function or wraps existing one if found.\r\n * This wrapped function attaches Firebase instance ID (FID) to gtag 'config' and\r\n * 'event' calls that belong to the GAID associated with this Firebase instance.\r\n *\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param dataLayerName Name of global GA datalayer array.\r\n * @param gtagFunctionName Name of global gtag function (\"gtag\" if not user-specified).\r\n */\r\nfunction wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagFunctionName) {\r\n    // Create a basic core gtag function\r\n    let gtagCore = function (..._args) {\r\n        // Must push IArguments object, not an array.\r\n        window[dataLayerName].push(arguments);\r\n    };\r\n    // Replace it with existing one if found\r\n    if (window[gtagFunctionName] &&\r\n        typeof window[gtagFunctionName] === 'function') {\r\n        // @ts-ignore\r\n        gtagCore = window[gtagFunctionName];\r\n    }\r\n    window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId);\r\n    return {\r\n        gtagCore,\r\n        wrappedGtag: window[gtagFunctionName]\r\n    };\r\n}\r\n/**\r\n * Returns the script tag in the DOM matching both the gtag url pattern\r\n * and the provided data layer name.\r\n */\r\nfunction findGtagScriptOnPage(dataLayerName) {\r\n    const scriptTags = window.document.getElementsByTagName('script');\r\n    for (const tag of Object.values(scriptTags)) {\r\n        if (tag.src &&\r\n            tag.src.includes(GTAG_URL) &&\r\n            tag.src.includes(dataLayerName)) {\r\n            return tag;\r\n        }\r\n    }\r\n    return null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Backoff factor for 503 errors, which we want to be conservative about\r\n * to avoid overloading servers. Each retry interval will be\r\n * BASE_INTERVAL_MILLIS * LONG_RETRY_FACTOR ^ retryCount, so the second one\r\n * will be ~30 seconds (with fuzzing).\r\n */\r\nconst LONG_RETRY_FACTOR = 30;\r\n/**\r\n * Base wait interval to multiplied by backoffFactor^backoffCount.\r\n */\r\nconst BASE_INTERVAL_MILLIS = 1000;\r\n/**\r\n * Stubbable retry data storage class.\r\n */\r\nclass RetryData {\r\n    constructor(throttleMetadata = {}, intervalMillis = BASE_INTERVAL_MILLIS) {\r\n        this.throttleMetadata = throttleMetadata;\r\n        this.intervalMillis = intervalMillis;\r\n    }\r\n    getThrottleMetadata(appId) {\r\n        return this.throttleMetadata[appId];\r\n    }\r\n    setThrottleMetadata(appId, metadata) {\r\n        this.throttleMetadata[appId] = metadata;\r\n    }\r\n    deleteThrottleMetadata(appId) {\r\n        delete this.throttleMetadata[appId];\r\n    }\r\n}\r\nconst defaultRetryData = new RetryData();\r\n/**\r\n * Set GET request headers.\r\n * @param apiKey App API key.\r\n */\r\nfunction getHeaders(apiKey) {\r\n    return new Headers({\r\n        Accept: 'application/json',\r\n        'x-goog-api-key': apiKey\r\n    });\r\n}\r\n/**\r\n * Fetches dynamic config from backend.\r\n * @param app Firebase app to fetch config for.\r\n */\r\nasync function fetchDynamicConfig(appFields) {\r\n    var _a;\r\n    const { appId, apiKey } = appFields;\r\n    const request = {\r\n        method: 'GET',\r\n        headers: getHeaders(apiKey)\r\n    };\r\n    const appUrl = DYNAMIC_CONFIG_URL.replace('{app-id}', appId);\r\n    const response = await fetch(appUrl, request);\r\n    if (response.status !== 200 && response.status !== 304) {\r\n        let errorMessage = '';\r\n        try {\r\n            // Try to get any error message text from server response.\r\n            const jsonResponse = (await response.json());\r\n            if ((_a = jsonResponse.error) === null || _a === void 0 ? void 0 : _a.message) {\r\n                errorMessage = jsonResponse.error.message;\r\n            }\r\n        }\r\n        catch (_ignored) { }\r\n        throw ERROR_FACTORY.create(\"config-fetch-failed\" /* AnalyticsError.CONFIG_FETCH_FAILED */, {\r\n            httpStatus: response.status,\r\n            responseMessage: errorMessage\r\n        });\r\n    }\r\n    return response.json();\r\n}\r\n/**\r\n * Fetches dynamic config from backend, retrying if failed.\r\n * @param app Firebase app to fetch config for.\r\n */\r\nasync function fetchDynamicConfigWithRetry(app, \r\n// retryData and timeoutMillis are parameterized to allow passing a different value for testing.\r\nretryData = defaultRetryData, timeoutMillis) {\r\n    const { appId, apiKey, measurementId } = app.options;\r\n    if (!appId) {\r\n        throw ERROR_FACTORY.create(\"no-app-id\" /* AnalyticsError.NO_APP_ID */);\r\n    }\r\n    if (!apiKey) {\r\n        if (measurementId) {\r\n            return {\r\n                measurementId,\r\n                appId\r\n            };\r\n        }\r\n        throw ERROR_FACTORY.create(\"no-api-key\" /* AnalyticsError.NO_API_KEY */);\r\n    }\r\n    const throttleMetadata = retryData.getThrottleMetadata(appId) || {\r\n        backoffCount: 0,\r\n        throttleEndTimeMillis: Date.now()\r\n    };\r\n    const signal = new AnalyticsAbortSignal();\r\n    setTimeout(async () => {\r\n        // Note a very low delay, eg < 10ms, can elapse before listeners are initialized.\r\n        signal.abort();\r\n    }, timeoutMillis !== undefined ? timeoutMillis : FETCH_TIMEOUT_MILLIS);\r\n    return attemptFetchDynamicConfigWithRetry({ appId, apiKey, measurementId }, throttleMetadata, signal, retryData);\r\n}\r\n/**\r\n * Runs one retry attempt.\r\n * @param appFields Necessary app config fields.\r\n * @param throttleMetadata Ongoing metadata to determine throttling times.\r\n * @param signal Abort signal.\r\n */\r\nasync function attemptFetchDynamicConfigWithRetry(appFields, { throttleEndTimeMillis, backoffCount }, signal, retryData = defaultRetryData // for testing\r\n) {\r\n    var _a;\r\n    const { appId, measurementId } = appFields;\r\n    // Starts with a (potentially zero) timeout to support resumption from stored state.\r\n    // Ensures the throttle end time is honored if the last attempt timed out.\r\n    // Note the SDK will never make a request if the fetch timeout expires at this point.\r\n    try {\r\n        await setAbortableTimeout(signal, throttleEndTimeMillis);\r\n    }\r\n    catch (e) {\r\n        if (measurementId) {\r\n            logger.warn(`Timed out fetching this Firebase app's measurement ID from the server.` +\r\n                ` Falling back to the measurement ID ${measurementId}` +\r\n                ` provided in the \"measurementId\" field in the local Firebase config. [${e === null || e === void 0 ? void 0 : e.message}]`);\r\n            return { appId, measurementId };\r\n        }\r\n        throw e;\r\n    }\r\n    try {\r\n        const response = await fetchDynamicConfig(appFields);\r\n        // Note the SDK only clears throttle state if response is success or non-retriable.\r\n        retryData.deleteThrottleMetadata(appId);\r\n        return response;\r\n    }\r\n    catch (e) {\r\n        const error = e;\r\n        if (!isRetriableError(error)) {\r\n            retryData.deleteThrottleMetadata(appId);\r\n            if (measurementId) {\r\n                logger.warn(`Failed to fetch this Firebase app's measurement ID from the server.` +\r\n                    ` Falling back to the measurement ID ${measurementId}` +\r\n                    ` provided in the \"measurementId\" field in the local Firebase config. [${error === null || error === void 0 ? void 0 : error.message}]`);\r\n                return { appId, measurementId };\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n        const backoffMillis = Number((_a = error === null || error === void 0 ? void 0 : error.customData) === null || _a === void 0 ? void 0 : _a.httpStatus) === 503\r\n            ? calculateBackoffMillis(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR)\r\n            : calculateBackoffMillis(backoffCount, retryData.intervalMillis);\r\n        // Increments backoff state.\r\n        const throttleMetadata = {\r\n            throttleEndTimeMillis: Date.now() + backoffMillis,\r\n            backoffCount: backoffCount + 1\r\n        };\r\n        // Persists state.\r\n        retryData.setThrottleMetadata(appId, throttleMetadata);\r\n        logger.debug(`Calling attemptFetch again in ${backoffMillis} millis`);\r\n        return attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData);\r\n    }\r\n}\r\n/**\r\n * Supports waiting on a backoff by:\r\n *\r\n * <ul>\r\n *   <li>Promisifying setTimeout, so we can set a timeout in our Promise chain</li>\r\n *   <li>Listening on a signal bus for abort events, just like the Fetch API</li>\r\n *   <li>Failing in the same way the Fetch API fails, so timing out a live request and a throttled\r\n *       request appear the same.</li>\r\n * </ul>\r\n *\r\n * <p>Visible for testing.\r\n */\r\nfunction setAbortableTimeout(signal, throttleEndTimeMillis) {\r\n    return new Promise((resolve, reject) => {\r\n        // Derives backoff from given end time, normalizing negative numbers to zero.\r\n        const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);\r\n        const timeout = setTimeout(resolve, backoffMillis);\r\n        // Adds listener, rather than sets onabort, because signal is a shared object.\r\n        signal.addEventListener(() => {\r\n            clearTimeout(timeout);\r\n            // If the request completes before this timeout, the rejection has no effect.\r\n            reject(ERROR_FACTORY.create(\"fetch-throttle\" /* AnalyticsError.FETCH_THROTTLE */, {\r\n                throttleEndTimeMillis\r\n            }));\r\n        });\r\n    });\r\n}\r\n/**\r\n * Returns true if the {@link Error} indicates a fetch request may succeed later.\r\n */\r\nfunction isRetriableError(e) {\r\n    if (!(e instanceof FirebaseError) || !e.customData) {\r\n        return false;\r\n    }\r\n    // Uses string index defined by ErrorData, which FirebaseError implements.\r\n    const httpStatus = Number(e.customData['httpStatus']);\r\n    return (httpStatus === 429 ||\r\n        httpStatus === 500 ||\r\n        httpStatus === 503 ||\r\n        httpStatus === 504);\r\n}\r\n/**\r\n * Shims a minimal AbortSignal (copied from Remote Config).\r\n *\r\n * <p>AbortController's AbortSignal conveniently decouples fetch timeout logic from other aspects\r\n * of networking, such as retries. Firebase doesn't use AbortController enough to justify a\r\n * polyfill recommendation, like we do with the Fetch API, but this minimal shim can easily be\r\n * swapped out if/when we do.\r\n */\r\nclass AnalyticsAbortSignal {\r\n    constructor() {\r\n        this.listeners = [];\r\n    }\r\n    addEventListener(listener) {\r\n        this.listeners.push(listener);\r\n    }\r\n    abort() {\r\n        this.listeners.forEach(listener => listener());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Event parameters to set on 'gtag' during initialization.\r\n */\r\nlet defaultEventParametersForInit;\r\n/**\r\n * Logs an analytics event through the Firebase SDK.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param eventName Google Analytics event name, choose from standard list or use a custom string.\r\n * @param eventParams Analytics event parameters.\r\n */\r\nasync function logEvent$1(gtagFunction, initializationPromise, eventName, eventParams, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"event\" /* GtagCommand.EVENT */, eventName, eventParams);\r\n        return;\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        const params = Object.assign(Object.assign({}, eventParams), { 'send_to': measurementId });\r\n        gtagFunction(\"event\" /* GtagCommand.EVENT */, eventName, params);\r\n    }\r\n}\r\n/**\r\n * Set screen_name parameter for this Google Analytics ID.\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param screenName Screen name string to set.\r\n */\r\nasync function setCurrentScreen$1(gtagFunction, initializationPromise, screenName, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"set\" /* GtagCommand.SET */, { 'screen_name': screenName });\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */, measurementId, {\r\n            update: true,\r\n            'screen_name': screenName\r\n        });\r\n    }\r\n}\r\n/**\r\n * Set user_id parameter for this Google Analytics ID.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param id User ID string to set\r\n */\r\nasync function setUserId$1(gtagFunction, initializationPromise, id, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"set\" /* GtagCommand.SET */, { 'user_id': id });\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */, measurementId, {\r\n            update: true,\r\n            'user_id': id\r\n        });\r\n    }\r\n}\r\n/**\r\n * Set all other user properties other than user_id and screen_name.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param properties Map of user properties to set\r\n */\r\nasync function setUserProperties$1(gtagFunction, initializationPromise, properties, options) {\r\n    if (options && options.global) {\r\n        const flatProperties = {};\r\n        for (const key of Object.keys(properties)) {\r\n            // use dot notation for merge behavior in gtag.js\r\n            flatProperties[`user_properties.${key}`] = properties[key];\r\n        }\r\n        gtagFunction(\"set\" /* GtagCommand.SET */, flatProperties);\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */, measurementId, {\r\n            update: true,\r\n            'user_properties': properties\r\n        });\r\n    }\r\n}\r\n/**\r\n * Retrieves a unique Google Analytics identifier for the web client.\r\n * See {@link https://developers.google.com/analytics/devguides/collection/ga4/reference/config#client_id | client_id}.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n */\r\nasync function internalGetGoogleAnalyticsClientId(gtagFunction, initializationPromise) {\r\n    const measurementId = await initializationPromise;\r\n    return new Promise((resolve, reject) => {\r\n        gtagFunction(\"get\" /* GtagCommand.GET */, measurementId, 'client_id', (clientId) => {\r\n            if (!clientId) {\r\n                reject(ERROR_FACTORY.create(\"no-client-id\" /* AnalyticsError.NO_CLIENT_ID */));\r\n            }\r\n            resolve(clientId);\r\n        });\r\n    });\r\n}\r\n/**\r\n * Set whether collection is enabled for this ID.\r\n *\r\n * @param enabled If true, collection is enabled for this ID.\r\n */\r\nasync function setAnalyticsCollectionEnabled$1(initializationPromise, enabled) {\r\n    const measurementId = await initializationPromise;\r\n    window[`ga-disable-${measurementId}`] = !enabled;\r\n}\r\n/**\r\n * Consent parameters to default to during 'gtag' initialization.\r\n */\r\nlet defaultConsentSettingsForInit;\r\n/**\r\n * Sets the variable {@link defaultConsentSettingsForInit} for use in the initialization of\r\n * analytics.\r\n *\r\n * @param consentSettings Maps the applicable end user consent state for gtag.js.\r\n */\r\nfunction _setConsentDefaultForInit(consentSettings) {\r\n    defaultConsentSettingsForInit = consentSettings;\r\n}\r\n/**\r\n * Sets the variable `defaultEventParametersForInit` for use in the initialization of\r\n * analytics.\r\n *\r\n * @param customParams Any custom params the user may pass to gtag.js.\r\n */\r\nfunction _setDefaultEventParametersForInit(customParams) {\r\n    defaultEventParametersForInit = customParams;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function validateIndexedDB() {\r\n    if (!isIndexedDBAvailable()) {\r\n        logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */, {\r\n            errorInfo: 'IndexedDB is not available in this environment.'\r\n        }).message);\r\n        return false;\r\n    }\r\n    else {\r\n        try {\r\n            await validateIndexedDBOpenable();\r\n        }\r\n        catch (e) {\r\n            logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */, {\r\n                errorInfo: e === null || e === void 0 ? void 0 : e.toString()\r\n            }).message);\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Initialize the analytics instance in gtag.js by calling config command with fid.\r\n *\r\n * NOTE: We combine analytics initialization and setting fid together because we want fid to be\r\n * part of the `page_view` event that's sent during the initialization\r\n * @param app Firebase app\r\n * @param gtagCore The gtag function that's not wrapped.\r\n * @param dynamicConfigPromisesList Array of all dynamic config promises.\r\n * @param measurementIdToAppId Maps measurementID to appID.\r\n * @param installations _FirebaseInstallationsInternal instance.\r\n *\r\n * @returns Measurement ID.\r\n */\r\nasync function _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCore, dataLayerName, options) {\r\n    var _a;\r\n    const dynamicConfigPromise = fetchDynamicConfigWithRetry(app);\r\n    // Once fetched, map measurementIds to appId, for ease of lookup in wrapped gtag function.\r\n    dynamicConfigPromise\r\n        .then(config => {\r\n        measurementIdToAppId[config.measurementId] = config.appId;\r\n        if (app.options.measurementId &&\r\n            config.measurementId !== app.options.measurementId) {\r\n            logger.warn(`The measurement ID in the local Firebase config (${app.options.measurementId})` +\r\n                ` does not match the measurement ID fetched from the server (${config.measurementId}).` +\r\n                ` To ensure analytics events are always sent to the correct Analytics property,` +\r\n                ` update the` +\r\n                ` measurement ID field in the local config or remove it from the local config.`);\r\n        }\r\n    })\r\n        .catch(e => logger.error(e));\r\n    // Add to list to track state of all dynamic config promises.\r\n    dynamicConfigPromisesList.push(dynamicConfigPromise);\r\n    const fidPromise = validateIndexedDB().then(envIsValid => {\r\n        if (envIsValid) {\r\n            return installations.getId();\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    });\r\n    const [dynamicConfig, fid] = await Promise.all([\r\n        dynamicConfigPromise,\r\n        fidPromise\r\n    ]);\r\n    // Detect if user has already put the gtag <script> tag on this page with the passed in\r\n    // data layer name.\r\n    if (!findGtagScriptOnPage(dataLayerName)) {\r\n        insertScriptTag(dataLayerName, dynamicConfig.measurementId);\r\n    }\r\n    // Detects if there are consent settings that need to be configured.\r\n    if (defaultConsentSettingsForInit) {\r\n        gtagCore(\"consent\" /* GtagCommand.CONSENT */, 'default', defaultConsentSettingsForInit);\r\n        _setConsentDefaultForInit(undefined);\r\n    }\r\n    // This command initializes gtag.js and only needs to be called once for the entire web app,\r\n    // but since it is idempotent, we can call it multiple times.\r\n    // We keep it together with other initialization logic for better code structure.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    gtagCore('js', new Date());\r\n    // User config added first. We don't want users to accidentally overwrite\r\n    // base Firebase config properties.\r\n    const configProperties = (_a = options === null || options === void 0 ? void 0 : options.config) !== null && _a !== void 0 ? _a : {};\r\n    // guard against developers accidentally setting properties with prefix `firebase_`\r\n    configProperties[ORIGIN_KEY] = 'firebase';\r\n    configProperties.update = true;\r\n    if (fid != null) {\r\n        configProperties[GA_FID_KEY] = fid;\r\n    }\r\n    // It should be the first config command called on this GA-ID\r\n    // Initialize this GA-ID and set FID on it using the gtag config API.\r\n    // Note: This will trigger a page_view event unless 'send_page_view' is set to false in\r\n    // `configProperties`.\r\n    gtagCore(\"config\" /* GtagCommand.CONFIG */, dynamicConfig.measurementId, configProperties);\r\n    // Detects if there is data that will be set on every event logged from the SDK.\r\n    if (defaultEventParametersForInit) {\r\n        gtagCore(\"set\" /* GtagCommand.SET */, defaultEventParametersForInit);\r\n        _setDefaultEventParametersForInit(undefined);\r\n    }\r\n    return dynamicConfig.measurementId;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Analytics Service class.\r\n */\r\nclass AnalyticsService {\r\n    constructor(app) {\r\n        this.app = app;\r\n    }\r\n    _delete() {\r\n        delete initializationPromisesMap[this.app.options.appId];\r\n        return Promise.resolve();\r\n    }\r\n}\r\n/**\r\n * Maps appId to full initialization promise. Wrapped gtag calls must wait on\r\n * all or some of these, depending on the call's `send_to` param and the status\r\n * of the dynamic config fetches (see below).\r\n */\r\nlet initializationPromisesMap = {};\r\n/**\r\n * List of dynamic config fetch promises. In certain cases, wrapped gtag calls\r\n * wait on all these to be complete in order to determine if it can selectively\r\n * wait for only certain initialization (FID) promises or if it must wait for all.\r\n */\r\nlet dynamicConfigPromisesList = [];\r\n/**\r\n * Maps fetched measurementIds to appId. Populated when the app's dynamic config\r\n * fetch completes. If already populated, gtag config calls can use this to\r\n * selectively wait for only this app's initialization promise (FID) instead of all\r\n * initialization promises.\r\n */\r\nconst measurementIdToAppId = {};\r\n/**\r\n * Name for window global data layer array used by GA: defaults to 'dataLayer'.\r\n */\r\nlet dataLayerName = 'dataLayer';\r\n/**\r\n * Name for window global gtag function used by GA: defaults to 'gtag'.\r\n */\r\nlet gtagName = 'gtag';\r\n/**\r\n * Reproduction of standard gtag function or reference to existing\r\n * gtag function on window object.\r\n */\r\nlet gtagCoreFunction;\r\n/**\r\n * Wrapper around gtag function that ensures FID is sent with all\r\n * relevant event and config calls.\r\n */\r\nlet wrappedGtagFunction;\r\n/**\r\n * Flag to ensure page initialization steps (creation or wrapping of\r\n * dataLayer and gtag script) are only run once per page load.\r\n */\r\nlet globalInitDone = false;\r\n/**\r\n * Configures Firebase Analytics to use custom `gtag` or `dataLayer` names.\r\n * Intended to be used if `gtag.js` script has been installed on\r\n * this page independently of Firebase Analytics, and is using non-default\r\n * names for either the `gtag` function or for `dataLayer`.\r\n * Must be called before calling `getAnalytics()` or it won't\r\n * have any effect.\r\n *\r\n * @public\r\n *\r\n * @param options - Custom gtag and dataLayer names.\r\n */\r\nfunction settings(options) {\r\n    if (globalInitDone) {\r\n        throw ERROR_FACTORY.create(\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */);\r\n    }\r\n    if (options.dataLayerName) {\r\n        dataLayerName = options.dataLayerName;\r\n    }\r\n    if (options.gtagName) {\r\n        gtagName = options.gtagName;\r\n    }\r\n}\r\n/**\r\n * Returns true if no environment mismatch is found.\r\n * If environment mismatches are found, throws an INVALID_ANALYTICS_CONTEXT\r\n * error that also lists details for each mismatch found.\r\n */\r\nfunction warnOnBrowserContextMismatch() {\r\n    const mismatchedEnvMessages = [];\r\n    if (isBrowserExtension()) {\r\n        mismatchedEnvMessages.push('This is a browser extension environment.');\r\n    }\r\n    if (!areCookiesEnabled()) {\r\n        mismatchedEnvMessages.push('Cookies are not available.');\r\n    }\r\n    if (mismatchedEnvMessages.length > 0) {\r\n        const details = mismatchedEnvMessages\r\n            .map((message, index) => `(${index + 1}) ${message}`)\r\n            .join(' ');\r\n        const err = ERROR_FACTORY.create(\"invalid-analytics-context\" /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */, {\r\n            errorInfo: details\r\n        });\r\n        logger.warn(err.message);\r\n    }\r\n}\r\n/**\r\n * Analytics instance factory.\r\n * @internal\r\n */\r\nfunction factory(app, installations, options) {\r\n    warnOnBrowserContextMismatch();\r\n    const appId = app.options.appId;\r\n    if (!appId) {\r\n        throw ERROR_FACTORY.create(\"no-app-id\" /* AnalyticsError.NO_APP_ID */);\r\n    }\r\n    if (!app.options.apiKey) {\r\n        if (app.options.measurementId) {\r\n            logger.warn(`The \"apiKey\" field is empty in the local Firebase config. This is needed to fetch the latest` +\r\n                ` measurement ID for this Firebase app. Falling back to the measurement ID ${app.options.measurementId}` +\r\n                ` provided in the \"measurementId\" field in the local Firebase config.`);\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"no-api-key\" /* AnalyticsError.NO_API_KEY */);\r\n        }\r\n    }\r\n    if (initializationPromisesMap[appId] != null) {\r\n        throw ERROR_FACTORY.create(\"already-exists\" /* AnalyticsError.ALREADY_EXISTS */, {\r\n            id: appId\r\n        });\r\n    }\r\n    if (!globalInitDone) {\r\n        // Steps here should only be done once per page: creation or wrapping\r\n        // of dataLayer and global gtag function.\r\n        getOrCreateDataLayer(dataLayerName);\r\n        const { wrappedGtag, gtagCore } = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName);\r\n        wrappedGtagFunction = wrappedGtag;\r\n        gtagCoreFunction = gtagCore;\r\n        globalInitDone = true;\r\n    }\r\n    // Async but non-blocking.\r\n    // This map reflects the completion state of all promises for each appId.\r\n    initializationPromisesMap[appId] = _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName, options);\r\n    const analyticsInstance = new AnalyticsService(app);\r\n    return analyticsInstance;\r\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nfunction getAnalytics(app = getApp()) {\r\n    app = getModularInstance(app);\r\n    // Dependencies\r\n    const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);\r\n    if (analyticsProvider.isInitialized()) {\r\n        return analyticsProvider.getImmediate();\r\n    }\r\n    return initializeAnalytics(app);\r\n}\r\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nfunction initializeAnalytics(app, options = {}) {\r\n    // Dependencies\r\n    const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);\r\n    if (analyticsProvider.isInitialized()) {\r\n        const existingInstance = analyticsProvider.getImmediate();\r\n        if (deepEqual(options, analyticsProvider.getOptions())) {\r\n            return existingInstance;\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */);\r\n        }\r\n    }\r\n    const analyticsInstance = analyticsProvider.initialize({ options });\r\n    return analyticsInstance;\r\n}\r\n/**\r\n * This is a public static method provided to users that wraps four different checks:\r\n *\r\n * 1. Check if it's not a browser extension environment.\r\n * 2. Check if cookies are enabled in current browser.\r\n * 3. Check if IndexedDB is supported by the browser environment.\r\n * 4. Check if the current browser context is valid for using `IndexedDB.open()`.\r\n *\r\n * @public\r\n *\r\n */\r\nasync function isSupported() {\r\n    if (isBrowserExtension()) {\r\n        return false;\r\n    }\r\n    if (!areCookiesEnabled()) {\r\n        return false;\r\n    }\r\n    if (!isIndexedDBAvailable()) {\r\n        return false;\r\n    }\r\n    try {\r\n        const isDBOpenable = await validateIndexedDBOpenable();\r\n        return isDBOpenable;\r\n    }\r\n    catch (error) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Use gtag `config` command to set `screen_name`.\r\n *\r\n * @public\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param screenName - Screen name to set.\r\n */\r\nfunction setCurrentScreen(analyticsInstance, screenName, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setCurrentScreen$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], screenName, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Retrieves a unique Google Analytics identifier for the web client.\r\n * See {@link https://developers.google.com/analytics/devguides/collection/ga4/reference/config#client_id | client_id}.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nasync function getGoogleAnalyticsClientId(analyticsInstance) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    return internalGetGoogleAnalyticsClientId(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId]);\r\n}\r\n/**\r\n * Use gtag `config` command to set `user_id`.\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param id - User ID to set.\r\n */\r\nfunction setUserId(analyticsInstance, id, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setUserId$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], id, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Use gtag `config` command to set all params specified.\r\n *\r\n * @public\r\n */\r\nfunction setUserProperties(analyticsInstance, properties, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setUserProperties$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], properties, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Sets whether Google Analytics collection is enabled for this app on this device.\r\n * Sets global `window['ga-disable-analyticsId'] = true;`\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param enabled - If true, enables collection, if false, disables it.\r\n */\r\nfunction setAnalyticsCollectionEnabled(analyticsInstance, enabled) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setAnalyticsCollectionEnabled$1(initializationPromisesMap[analyticsInstance.app.options.appId], enabled).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Adds data that will be set on every event logged from the SDK, including automatic ones.\r\n * With gtag's \"set\" command, the values passed persist on the current page and are passed with\r\n * all subsequent events.\r\n * @public\r\n * @param customParams - Any custom params the user may pass to gtag.js.\r\n */\r\nfunction setDefaultEventParameters(customParams) {\r\n    // Check if reference to existing gtag function on window object exists\r\n    if (wrappedGtagFunction) {\r\n        wrappedGtagFunction(\"set\" /* GtagCommand.SET */, customParams);\r\n    }\r\n    else {\r\n        _setDefaultEventParametersForInit(customParams);\r\n    }\r\n}\r\n/**\r\n * Sends a Google Analytics event with given `eventParams`. This method\r\n * automatically associates this logged event with this Firebase web\r\n * app instance on this device.\r\n * List of official event parameters can be found in the gtag.js\r\n * reference documentation:\r\n * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n * | the GA4 reference documentation}.\r\n *\r\n * @public\r\n */\r\nfunction logEvent(analyticsInstance, eventName, eventParams, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    logEvent$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], eventName, eventParams, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Sets the applicable end user consent state for this web app across all gtag references once\r\n * Firebase Analytics is initialized.\r\n *\r\n * Use the {@link ConsentSettings} to specify individual consent type values. By default consent\r\n * types are set to \"granted\".\r\n * @public\r\n * @param consentSettings - Maps the applicable end user consent state for gtag.js.\r\n */\r\nfunction setConsent(consentSettings) {\r\n    // Check if reference to existing gtag function on window object exists\r\n    if (wrappedGtagFunction) {\r\n        wrappedGtagFunction(\"consent\" /* GtagCommand.CONSENT */, 'update', consentSettings);\r\n    }\r\n    else {\r\n        _setConsentDefaultForInit(consentSettings);\r\n    }\r\n}\n\nconst name = \"@firebase/analytics\";\nconst version = \"0.10.8\";\n\n/**\r\n * The Firebase Analytics Web SDK.\r\n * This SDK does not work in a Node.js environment.\r\n *\r\n * @packageDocumentation\r\n */\r\nfunction registerAnalytics() {\r\n    _registerComponent(new Component(ANALYTICS_TYPE, (container, { options: analyticsOptions }) => {\r\n        // getImmediate for FirebaseApp will always succeed\r\n        const app = container.getProvider('app').getImmediate();\r\n        const installations = container\r\n            .getProvider('installations-internal')\r\n            .getImmediate();\r\n        return factory(app, installations, analyticsOptions);\r\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */));\r\n    _registerComponent(new Component('analytics-internal', internalFactory, \"PRIVATE\" /* ComponentType.PRIVATE */));\r\n    registerVersion(name, version);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    registerVersion(name, version, 'esm2017');\r\n    function internalFactory(container) {\r\n        try {\r\n            const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();\r\n            return {\r\n                logEvent: (eventName, eventParams, options) => logEvent(analytics, eventName, eventParams, options)\r\n            };\r\n        }\r\n        catch (e) {\r\n            throw ERROR_FACTORY.create(\"interop-component-reg-failed\" /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */, {\r\n                reason: e\r\n            });\r\n        }\r\n    }\r\n}\r\nregisterAnalytics();\n\nexport { getAnalytics, getGoogleAnalyticsClientId, initializeAnalytics, isSupported, logEvent, setAnalyticsCollectionEnabled, setConsent, setCurrentScreen, setDefaultEventParameters, setUserId, setUserProperties, settings };\n//# sourceMappingURL=index.esm2017.js.map\n","import { initializeApp, type FirebaseApp } from 'firebase/app';\nimport { getAuth, connectAuthEmulator, type Auth } from 'firebase/auth';\nimport { getAnalytics, type Analytics } from 'firebase/analytics';\nimport { getFirestore, type Firestore } from 'firebase/firestore';\nimport { browser } from '$app/environment';\n\n// Firebase configuration\nconst firebaseConfig = {\n  apiKey: import.meta.env.VITE_FIREBASE_API_KEY || \"demo-key-for-development\",\n  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN || \"demo-project.firebaseapp.com\",\n  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID || \"demo-project\",\n  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET || \"demo-project.appspot.com\",\n  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID || \"123456789\",\n  appId: import.meta.env.VITE_FIREBASE_APP_ID || \"1:123456789:web:a1b2c3d4e5f6\",\n  measurementId: import.meta.env.VITE_FIREBASE_MEASUREMENT_ID || \"G-ABCDEF\"\n};\n\n// For debugging - only log in development\nconst isDev = import.meta.env.DEV;\nconst logDebug = (message: string, data?: any) => {\n  if (isDev && browser) {\n    console.log(message, data);\n  }\n};\n\n// Declare Firebase service variables with proper TypeScript types\nlet app: FirebaseApp;\nlet auth: Auth;\nlet analytics: Analytics | null = null;\nlet db: Firestore;\n\n// Only initialize Firebase in the browser environment\nif (browser) {\n  try {\n    logDebug('Initializing Firebase app');\n    app = initializeApp(firebaseConfig);\n    \n    // Initialize Firebase Authentication\n    auth = getAuth(app);\n    \n    // Initialize Firestore\n    db = getFirestore(app);\n    \n    // Use auth emulator if in development\n    if (isDev && import.meta.env.VITE_USE_FIREBASE_EMULATOR === 'true') {\n      logDebug('Connecting to Firebase Auth emulator');\n      connectAuthEmulator(auth, 'http://localhost:9099');\n    }\n\n    // Initialize Analytics\n    try {\n      analytics = getAnalytics(app);\n      logDebug('Firebase analytics initialized');\n    } catch (error) {\n      if (isDev) {\n        console.warn('Failed to initialize Firebase Analytics:', error);\n      }\n    }\n    \n    logDebug('Firebase initialized successfully');\n  } catch (error) {\n    console.error('Error initializing Firebase:', error);\n  }\n} else {\n  // Create empty mock instances for SSR\n  // This prevents errors during server-side rendering\n  const mockApp = {} as FirebaseApp;\n  const mockAuth = {} as Auth;\n  const mockDb = {} as Firestore;\n  \n  app = mockApp;\n  auth = mockAuth;\n  db = mockDb;\n}\n\n// Export Firebase services\nexport { app, auth, db, analytics };","export interface UserPreferences {\n  enrollments?: Array<{\n    courseId: string;\n    progress: number;\n    startedAt: number;\n    lastAccessedAt: number;\n  }>;\n  focusSessions?: Array<{\n    duration: number;\n    timestamp: number;\n    task?: string;\n  }>;\n  tasks?: Array<{\n    id: string;\n    text: string;\n    completed: boolean;\n    deadline?: string;\n    priority?: number;\n  }>;\n  notes?: string;\n  theme?: 'light' | 'dark' | 'system';\n  languagePreference?: string;\n  notificationSettings?: {\n    email: boolean;\n    push: boolean;\n    dailyDigest: boolean;\n  };\n}\n\nexport interface UserProfile {\n  uid: string;\n  email: string;\n  displayName?: string;\n  createdAt: number;\n  updatedAt?: number;\n  photoURL?: string;\n  bio?: string;\n  location?: string;\n  website?: string;\n  preferences?: UserPreferences;\n}\n\n/**\n * Error class for user service operations\n */\nexport class UserServiceError extends Error {\n  constructor(message: string, public code: string, public originalError?: any) {\n    super(message);\n    this.name = 'UserServiceError';\n  }\n}\n\n/**\n * Load the user profile from Firestore. Returns null if not found.\n */\nexport async function getUserProfile(uid: string): Promise<UserProfile | null> {\n  try {\n    if (!uid) {\n      throw new UserServiceError('User ID is required', 'invalid-argument');\n    }\n\n    if (typeof window === 'undefined') return null;\n    \n    const { getFirestore, doc, getDoc } = await import('firebase/firestore');\n    const { app } = await import('../firebase.js');\n    const db = getFirestore(app);\n    const ref = doc(db, 'users', uid);\n    \n    const snap = await getDoc(ref);\n    if (snap.exists()) {\n      return snap.data() as UserProfile;\n    }\n    return null;\n  } catch (err: any) {\n    console.error('Error getting user profile:', err);\n    \n    // Create a standardized error object\n    const errorCode = err.code || 'unknown';\n    const errorMessage = err.message || 'Failed to get user profile';\n    \n    throw new UserServiceError(errorMessage, errorCode, err);\n  }\n}\n\n/**\n * Create a new user profile document in Firestore.\n */\nexport async function createUserProfile(profile: UserProfile): Promise<void> {\n  try {\n    if (!profile || !profile.uid) {\n      throw new UserServiceError('Valid user profile with UID is required', 'invalid-argument');\n    }\n    \n    if (typeof window === 'undefined') return;\n    \n    const { getFirestore, doc, setDoc } = await import('firebase/firestore');\n    const { app } = await import('../firebase.js');\n    const db = getFirestore(app);\n    const ref = doc(db, 'users', profile.uid);\n    \n    await setDoc(ref, profile);\n    console.log(`User profile created: ${profile.uid}`);\n  } catch (err: any) {\n    console.error('Error creating user profile:', err);\n    \n    // Create a standardized error object\n    const errorCode = err.code || 'unknown';\n    const errorMessage = err.message || 'Failed to create user profile';\n    \n    throw new UserServiceError(errorMessage, errorCode, err);\n  }\n}\n\n/**\n * Update existing user profile fields.\n */\nexport async function updateUserProfile(uid: string, data: Partial<UserProfile>): Promise<void> {\n  try {\n    if (!uid) {\n      throw new UserServiceError('User ID is required', 'invalid-argument');\n    }\n    \n    if (!data || Object.keys(data).length === 0) {\n      throw new UserServiceError('Update data is required', 'invalid-argument');\n    }\n    \n    if (typeof window === 'undefined') return;\n    \n    const { getFirestore, doc, updateDoc } = await import('firebase/firestore');\n    const { app } = await import('../firebase.js');\n    const db = getFirestore(app);\n    const ref = doc(db, 'users', uid);\n    \n    await updateDoc(ref, data);\n    console.log(`User profile updated: ${uid}`);\n  } catch (err: any) {\n    console.error('Error updating user profile:', err);\n    \n    // Create a standardized error object\n    const errorCode = err.code || 'unknown';\n    const errorMessage = err.message || 'Failed to update user profile';\n    \n    throw new UserServiceError(errorMessage, errorCode, err);\n  }\n}\n\n/**\n * Check if a user profile exists\n */\nexport async function userProfileExists(uid: string): Promise<boolean> {\n  try {\n    if (!uid) return false;\n    \n    const profile = await getUserProfile(uid);\n    return profile !== null;\n  } catch (err) {\n    console.error('Error checking if user profile exists:', err);\n    return false;\n  }\n}\n","import { writable } from 'svelte/store';\nimport type { User } from 'firebase/auth';\nimport type { UserProfile } from '../services/userService.js';\nimport { getUserProfile, createUserProfile, updateUserProfile as updateUserProfileService } from '../services/userService.js';\n\nexport const userProfile = writable<UserProfile | null>(null);\nexport const userProfileLoading = writable<boolean>(false);\nexport const userProfileError = writable<string | null>(null);\n\n/**\n * Load or create the user profile for the given UID and email/displayName.\n */\nexport async function loadUserProfile(uid: string, email: string, displayName?: string): Promise<void> {\n  userProfileLoading.set(true);\n  userProfileError.set(null);\n\n  try {\n    let profile = await getUserProfile(uid);\n    if (!profile) {\n      // create new profile\n      const now = Date.now();\n      profile = {\n        uid,\n        email,\n        displayName,\n        createdAt: now,\n        preferences: {\n          enrollments: [],\n          focusSessions: [],\n          tasks: [],\n          notes: ''\n        }\n      };\n      await createUserProfile(profile);\n    }\n    userProfile.set(profile);\n  } catch (err: any) {\n    console.error('Error loading user profile:', err);\n    userProfileError.set(err.message);\n    userProfile.set(null);\n  } finally {\n    userProfileLoading.set(false);\n  }\n}\n\nexport const updateUserProfile = updateUserProfileService;","import { \n\tcreateUserWithEmailAndPassword,\n\tsignInWithEmailAndPassword,\n\tsignOut as firebaseSignOut,\n\tonAuthStateChanged,\n\tsendPasswordResetEmail,\n\tupdateProfile,\n\tGoogleAuthProvider,\n\tsignInWithPopup,\n\tsetPersistence,\n\tbrowserLocalPersistence,\n\tbrowserSessionPersistence,\n\ttype User,\n\ttype UserCredential,\n\ttype AuthError,\n\ttype Auth\n} from 'firebase/auth';\nimport { auth } from './firebase.js';\nimport { isAuthenticated, user, loading, authError } from './stores/authStore.js';\nimport { loadUserProfile } from './stores/userProfileStore.js';\nimport { browser } from '$app/environment';\n\n// Custom error type for auth operations\ntype AuthOperationError = {\n\tcode?: string;\n\tmessage: string;\n\toriginal?: any;\n};\n\n// Flag to track if auth initialization has completed\nlet authInitialized = false;\n\n// Initialize the auth listener\nfunction initAuth() {\n\tif (!browser) return; // Don't initialize auth in SSR contexts\n\t\n\tif (authInitialized) {\n\t\tconsole.log('Auth already initialized, skipping');\n\t\treturn;\n\t}\n\t\n\tloading.set(true);\n\tconsole.log('Initializing auth listener');\n\t\n\t// Set up an observer to watch for auth state changes\n\tconst unsubscribe = onAuthStateChanged(auth, \n\t\t(userData: User | null) => {\n\t\t\tif (userData) {\n\t\t\t\tconsole.log('Auth state changed: User authenticated', {\n\t\t\t\t\tuid: userData.uid,\n\t\t\t\t\temail: userData.email,\n\t\t\t\t\tdisplayName: userData.displayName\n\t\t\t\t});\n\t\t\t\tisAuthenticated.set(true);\n\t\t\t\tuser.set(userData);\n\t\t\t\t// Load or initialize Firestore user profile\n\t\t\t\tloadUserProfile(userData.uid, userData.email || '', userData.displayName || undefined)\n\t\t\t\t\t\t.catch((err: Error) => {\n\t\t\t\t\t\t\tconsole.error('Failed to load user profile:', err);\n\t\t\t\t\t\t\t// Don't fail authentication if profile loading fails\n\t\t\t\t\t\t\t// But store the error for potential display or retry logic\n\t\t\t\t\t\t\tauthError.set('Your profile information could not be loaded. Some features may be limited.');\n\t\t\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconsole.log('Auth state changed: User not authenticated');\n\t\t\t\tisAuthenticated.set(false);\n\t\t\t\tuser.set(null);\n\t\t\t}\n\t\t\tloading.set(false);\n\t\t\tauthInitialized = true;\n\t\t}, \n\t\t(error: Error) => {\n\t\t\tconsole.error('Auth state change error:', error);\n\t\t\tauthError.set(`Authentication error: ${error.message}`);\n\t\t\tloading.set(false);\n\t\t\tauthInitialized = true;\n\t\t}\n\t);\n\t\n\t// Return unsubscribe function in case we need to detach the listener\n\treturn unsubscribe;\n}\n\n// Set auth persistence based on \"remember me\" preference\nasync function setAuthPersistence(rememberMe: boolean): Promise<void> {\n\tif (!browser) return; // Skip in SSR context\n\t\n\ttry {\n\t\tconst persistenceType = rememberMe ? browserLocalPersistence : browserSessionPersistence;\n\t\tawait setPersistence(auth, persistenceType);\n\t\tconsole.log(`Auth persistence set to: ${rememberMe ? 'LOCAL' : 'SESSION'}`);\n\t} catch (error) {\n\t\tconsole.error('Failed to set auth persistence:', error);\n\t\t// Continue with auth operation even if persistence setting fails\n\t}\n}\n\n// Helper function to format Firebase auth errors\nfunction formatAuthError(error: any): AuthOperationError {\n\tlet code = error?.code || '';\n\tlet message = 'An unexpected error occurred. Please try again.';\n\t\n\t// Common Firebase auth error codes\n\tconst errorMap: Record<string, string> = {\n\t\t// Registration errors\n\t\t'auth/email-already-in-use': 'This email is already registered. Please use a different email or try logging in.',\n\t\t'auth/invalid-email': 'The email address is not valid.',\n\t\t'auth/weak-password': 'Password is too weak. Please use a stronger password.',\n\t\t\n\t\t// Login errors\n\t\t'auth/user-not-found': 'Invalid email or password. Please try again.',\n\t\t'auth/wrong-password': 'Invalid email or password. Please try again.',\n\t\t'auth/invalid-credential': 'Invalid email or password. Please try again.',\n\t\t'auth/user-disabled': 'This account has been disabled. Please contact support.',\n\t\t'auth/too-many-requests': 'Too many unsuccessful login attempts. Please try again later or reset your password.',\n\t\t\n\t\t// Google sign-in errors\n\t\t'auth/popup-closed-by-user': 'Sign-in popup was closed before completion. Please try again.',\n\t\t'auth/popup-blocked': 'Sign-in popup was blocked by your browser. Please allow popups for this site and try again.',\n\t\t'auth/cancelled-popup-request': 'Multiple popup requests were detected. Please try again.',\n\t\t'auth/account-exists-with-different-credential': 'An account already exists with the same email but different sign-in credentials. Try signing in with a different method.',\n\t\t\n\t\t// Password reset errors\n\t\t'auth/missing-email': 'Please enter an email address.',\n\t\t\n\t\t// Network errors\n\t\t'auth/network-request-failed': 'Network error. Please check your connection and try again.',\n\t\t\n\t\t// Default for unknown errors\n\t\t'default': 'An unexpected error occurred. Please try again.'\n\t};\n\t\n\t// Get the specific error message or use default\n\tmessage = errorMap[code] || errorMap['default'];\n\t\n\treturn {\n\t\tcode,\n\t\tmessage,\n\t\toriginal: error\n\t};\n}\n\n// Register a new user with email and password\nasync function register(email: string, password: string, displayName: string, rememberMe: boolean = true): Promise<void> {\n\tif (!browser) return Promise.reject(new Error('Cannot register in server context')); \n\t\n\tloading.set(true);\n\tauthError.set('');\n\tconsole.log('Attempting to register user:', { email, displayName });\n\t\n\ttry {\n\t\t// Set persistence before registration\n\t\tawait setAuthPersistence(rememberMe);\n\t\t\n\t\tconst userCredential = await createUserWithEmailAndPassword(auth, email, password);\n\t\t// Update the user profile with display name\n\t\tif (userCredential.user) {\n\t\t\tawait updateProfile(userCredential.user, { displayName });\n\t\t\tconsole.log('User registered successfully');\n\t\t}\n\t} catch (error: any) {\n\t\tconsole.error('Registration error:', error);\n\t\tconst formattedError = formatAuthError(error);\n\t\tauthError.set(formattedError.message);\n\t\tthrow error;\n\t} finally {\n\t\tloading.set(false);\n\t}\n}\n\n// Login with email and password\nasync function login(email: string, password: string, rememberMe: boolean = true): Promise<void> {\n\tif (!browser) return Promise.reject(new Error('Cannot login in server context'));\n\t\n\tloading.set(true);\n\tauthError.set('');\n\tconsole.log('Attempting to login user:', { email });\n\t\n\ttry {\n\t\t// Set persistence before login\n\t\tawait setAuthPersistence(rememberMe);\n\t\t\n\t\tconst result = await signInWithEmailAndPassword(auth, email, password);\n\t\tconsole.log('Login successful:', { \n\t\t\tuid: result.user.uid,\n\t\t\temail: result.user.email,\n\t\t\tdisplayName: result.user.displayName,\n\t\t\temailVerified: result.user.emailVerified\n\t\t});\n\t} catch (error: any) {\n\t\tconsole.error('Login error:', error);\n\t\tconst formattedError = formatAuthError(error);\n\t\tauthError.set(formattedError.message);\n\t\tthrow error;\n\t} finally {\n\t\tloading.set(false);\n\t}\n}\n\n// Sign in with Google\nasync function loginWithGoogle(rememberMe: boolean = true): Promise<void> {\n\tif (!browser) return Promise.reject(new Error('Cannot login with Google in server context'));\n\t\n\tloading.set(true);\n\tauthError.set('');\n\tconsole.log('Attempting Google sign-in');\n\t\n\ttry {\n\t\t// Set persistence before Google login\n\t\tawait setAuthPersistence(rememberMe);\n\t\t\n\t\tconst provider = new GoogleAuthProvider();\n\t\tconst result = await signInWithPopup(auth, provider);\n\t\tconsole.log('Google sign-in successful:', { \n\t\t\tuid: result.user.uid,\n\t\t\temail: result.user.email,\n\t\t\tdisplayName: result.user.displayName\n\t\t});\n\t} catch (error: any) {\n\t\tconsole.error('Google sign-in error:', error);\n\t\tconst formattedError = formatAuthError(error);\n\t\tauthError.set(formattedError.message);\n\t\tthrow error;\n\t} finally {\n\t\tloading.set(false);\n\t}\n}\n\n// Logout the user\nasync function logout(): Promise<void> {\n\tif (!browser) return Promise.reject(new Error('Cannot logout in server context'));\n\t\n\tloading.set(true);\n\tauthError.set('');\n\tconsole.log('Logging out user');\n\t\n\ttry {\n\t\tawait firebaseSignOut(auth);\n\t\tconsole.log('Logout successful');\n\t} catch (error: any) {\n\t\tconsole.error('Logout error:', error);\n\t\tauthError.set('Failed to log out. Please try again.');\n\t\tthrow error;\n\t} finally {\n\t\tloading.set(false);\n\t}\n}\n\n// Reset password\nasync function resetPassword(email: string): Promise<void> {\n\tif (!browser) return Promise.reject(new Error('Cannot reset password in server context'));\n\t\n\tloading.set(true);\n\tauthError.set('');\n\tconsole.log('Requesting password reset for:', { email });\n\t\n\ttry {\n\t\tawait sendPasswordResetEmail(auth, email);\n\t\tconsole.log('Password reset email sent');\n\t} catch (error: any) {\n\t\tconsole.error('Password reset error:', error);\n\t\tconst formattedError = formatAuthError(error);\n\t\tauthError.set(formattedError.message);\n\t\tthrow error;\n\t} finally {\n\t\tloading.set(false);\n\t}\n}\n\n// Get current user\nfunction getCurrentUser(): User | null {\n\tif (!browser) return null; // Don't access auth in SSR contexts\n\t\n\tconst currentUser = auth.currentUser;\n\tconsole.log('Getting current user:', currentUser ? {\n\t\tuid: currentUser.uid,\n\t\temail: currentUser.email,\n\t\tdisplayName: currentUser.displayName\n\t} : 'No user');\n\treturn currentUser;\n}\n\nexport {\n\tinitAuth,\n\tregister,\n\tlogin,\n\tloginWithGoogle,\n\tlogout,\n\tresetPassword,\n\tgetCurrentUser,\n\tupdateProfile\n};","import { writable, derived } from 'svelte/store';\nimport type { User } from 'firebase/auth';\nimport { logout as firebaseLogout } from '../authService.js';\n\nexport const isAuthenticated = writable<boolean>(false);\nexport const user = writable<User | null>(null);\nexport const loading = writable<boolean>(true);\nexport const authError = writable<string | null>(null);\n\n// Add custom user type that extends Firebase User\ninterface CustomUser extends User {\n  isAdmin?: boolean;\n}\n\nexport const isAdmin = derived(user, ($user) => {\n  // Example: check for a custom claim or email\n  if (!$user) return false;\n  // You can customize this logic as needed\n  return $user.email === 'admin@example.com' || ($user as CustomUser)?.isAdmin === true;\n});\n\nexport const logout = firebaseLogout;"],"file":"_app/immutable/chunks/BRK8y73W.js"}