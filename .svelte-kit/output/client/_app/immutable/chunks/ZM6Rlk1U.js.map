{"version":3,"file":"ZM6Rlk1U.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/elements/misc.js","../../../../../../node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js","../../../../../../node_modules/svelte/src/internal/client/dom/elements/events.js","../../../../../../node_modules/svelte/src/internal/client/dom/reconciler.js","../../../../../../node_modules/svelte/src/internal/client/dom/template.js"],"sourcesContent":["import { hydrating } from '../hydration.js';\nimport { clear_text_content, get_first_child } from '../operations.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * @param {HTMLElement} dom\n * @param {boolean} value\n * @returns {void}\n */\nexport function autofocus(dom, value) {\n\tif (value) {\n\t\tconst body = document.body;\n\t\tdom.autofocus = true;\n\n\t\tqueue_micro_task(() => {\n\t\t\tif (document.activeElement === body) {\n\t\t\t\tdom.focus();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * The child of a textarea actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLTextAreaElement} dom\n * @returns {void}\n */\nexport function remove_textarea_child(dom) {\n\tif (hydrating && get_first_child(dom) !== null) {\n\t\tclear_text_content(dom);\n\t}\n}\n\nlet listening_to_form_reset = false;\n\nexport function add_form_reset_listener() {\n\tif (!listening_to_form_reset) {\n\t\tlistening_to_form_reset = true;\n\t\tdocument.addEventListener(\n\t\t\t'reset',\n\t\t\t(evt) => {\n\t\t\t\t// Needs to happen one tick later or else the dom properties of the form\n\t\t\t\t// elements have not updated to their reset values yet\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tif (!evt.defaultPrevented) {\n\t\t\t\t\t\tfor (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {\n\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\te.__on_r?.();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)\n\t\t\t{ capture: true }\n\t\t);\n\t}\n}\n","import { teardown } from '../../../reactivity/effects.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../../runtime.js';\nimport { add_form_reset_listener } from '../misc.js';\n\n/**\n * Fires the handler once immediately (unless corresponding arg is set to `false`),\n * then listens to the given events until the render effect context is destroyed\n * @param {EventTarget} target\n * @param {Array<string>} events\n * @param {(event?: Event) => void} handler\n * @param {any} call_handler_immediately\n */\nexport function listen(target, events, handler, call_handler_immediately = true) {\n\tif (call_handler_immediately) {\n\t\thandler();\n\t}\n\n\tfor (var name of events) {\n\t\ttarget.addEventListener(name, handler);\n\t}\n\n\tteardown(() => {\n\t\tfor (var name of events) {\n\t\t\ttarget.removeEventListener(name, handler);\n\t\t}\n\t});\n}\n\n/**\n * @template T\n * @param {() => T} fn\n */\nexport function without_reactive_context(fn) {\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * Listen to the given event, and then instantiate a global form reset listener if not already done,\n * to notify all bindings when the form is reset\n * @param {HTMLElement} element\n * @param {string} event\n * @param {(is_reset?: true) => void} handler\n * @param {(is_reset?: true) => void} [on_reset]\n */\nexport function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {\n\telement.addEventListener(event, () => without_reactive_context(handler));\n\t// @ts-expect-error\n\tconst prev = element.__on_r;\n\tif (prev) {\n\t\t// special case for checkbox that can have multiple binds (group & checked)\n\t\t// @ts-expect-error\n\t\telement.__on_r = () => {\n\t\t\tprev();\n\t\t\ton_reset(true);\n\t\t};\n\t} else {\n\t\t// @ts-expect-error\n\t\telement.__on_r = () => on_reset(true);\n\t}\n\n\tadd_form_reset_listener();\n}\n","import { teardown } from '../../reactivity/effects.js';\nimport { define_property, is_array } from '../../../shared/utils.js';\nimport { hydrating } from '../hydration.js';\nimport { queue_micro_task } from '../task.js';\nimport { FILENAME } from '../../../../constants.js';\nimport * as w from '../../warnings.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../runtime.js';\nimport { without_reactive_context } from './bindings/shared.js';\n\n/** @type {Set<string>} */\nexport const all_registered_events = new Set();\n\n/** @type {Set<(events: Array<string>) => void>} */\nexport const root_event_handles = new Set();\n\n/**\n * SSR adds onload and onerror attributes to catch those events before the hydration.\n * This function detects those cases, removes the attributes and replays the events.\n * @param {HTMLElement} dom\n */\nexport function replay_events(dom) {\n\tif (!hydrating) return;\n\n\tif (dom.onload) {\n\t\tdom.removeAttribute('onload');\n\t}\n\tif (dom.onerror) {\n\t\tdom.removeAttribute('onerror');\n\t}\n\t// @ts-expect-error\n\tconst event = dom.__e;\n\tif (event !== undefined) {\n\t\t// @ts-expect-error\n\t\tdom.__e = undefined;\n\t\tqueueMicrotask(() => {\n\t\t\tif (dom.isConnected) {\n\t\t\t\tdom.dispatchEvent(event);\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @param {string} event_name\n * @param {EventTarget} dom\n * @param {EventListener} [handler]\n * @param {AddEventListenerOptions} [options]\n */\nexport function create_event(event_name, dom, handler, options = {}) {\n\t/**\n\t * @this {EventTarget}\n\t */\n\tfunction target_handler(/** @type {Event} */ event) {\n\t\tif (!options.capture) {\n\t\t\t// Only call in the bubble phase, else delegated events would be called before the capturing events\n\t\t\thandle_event_propagation.call(dom, event);\n\t\t}\n\t\tif (!event.cancelBubble) {\n\t\t\treturn without_reactive_context(() => {\n\t\t\t\treturn handler?.call(this, event);\n\t\t\t});\n\t\t}\n\t}\n\n\t// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned\n\t// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we\n\t// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes\n\t// this bug. The same applies to wheel events and touch events.\n\tif (\n\t\tevent_name.startsWith('pointer') ||\n\t\tevent_name.startsWith('touch') ||\n\t\tevent_name === 'wheel'\n\t) {\n\t\tqueue_micro_task(() => {\n\t\t\tdom.addEventListener(event_name, target_handler, options);\n\t\t});\n\t} else {\n\t\tdom.addEventListener(event_name, target_handler, options);\n\t}\n\n\treturn target_handler;\n}\n\n/**\n * Attaches an event handler to an element and returns a function that removes the handler. Using this\n * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively\n * (with attributes like `onclick`), which use event delegation for performance reasons\n *\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} [options]\n */\nexport function on(element, type, handler, options = {}) {\n\tvar target_handler = create_event(type, element, handler, options);\n\n\treturn () => {\n\t\telement.removeEventListener(type, target_handler, options);\n\t};\n}\n\n/**\n * @param {string} event_name\n * @param {Element} dom\n * @param {EventListener} [handler]\n * @param {boolean} [capture]\n * @param {boolean} [passive]\n * @returns {void}\n */\nexport function event(event_name, dom, handler, capture, passive) {\n\tvar options = { capture, passive };\n\tvar target_handler = create_event(event_name, dom, handler, options);\n\n\t// @ts-ignore\n\tif (dom === document.body || dom === window || dom === document) {\n\t\tteardown(() => {\n\t\t\tdom.removeEventListener(event_name, target_handler, options);\n\t\t});\n\t}\n}\n\n/**\n * @param {Array<string>} events\n * @returns {void}\n */\nexport function delegate(events) {\n\tfor (var i = 0; i < events.length; i++) {\n\t\tall_registered_events.add(events[i]);\n\t}\n\n\tfor (var fn of root_event_handles) {\n\t\tfn(events);\n\t}\n}\n\n/**\n * @this {EventTarget}\n * @param {Event} event\n * @returns {void}\n */\nexport function handle_event_propagation(event) {\n\tvar handler_element = this;\n\tvar owner_document = /** @type {Node} */ (handler_element).ownerDocument;\n\tvar event_name = event.type;\n\tvar path = event.composedPath?.() || [];\n\tvar current_target = /** @type {null | Element} */ (path[0] || event.target);\n\n\t// composedPath contains list of nodes the event has propagated through.\n\t// We check __root to skip all nodes below it in case this is a\n\t// parent of the __root node, which indicates that there's nested\n\t// mounted apps. In this case we don't want to trigger events multiple times.\n\tvar path_idx = 0;\n\n\t// @ts-expect-error is added below\n\tvar handled_at = event.__root;\n\n\tif (handled_at) {\n\t\tvar at_idx = path.indexOf(handled_at);\n\t\tif (\n\t\t\tat_idx !== -1 &&\n\t\t\t(handler_element === document || handler_element === /** @type {any} */ (window))\n\t\t) {\n\t\t\t// This is the fallback document listener or a window listener, but the event was already handled\n\t\t\t// -> ignore, but set handle_at to document/window so that we're resetting the event\n\t\t\t// chain in case someone manually dispatches the same event object again.\n\t\t\t// @ts-expect-error\n\t\t\tevent.__root = handler_element;\n\t\t\treturn;\n\t\t}\n\n\t\t// We're deliberately not skipping if the index is higher, because\n\t\t// someone could create an event programmatically and emit it multiple times,\n\t\t// in which case we want to handle the whole propagation chain properly each time.\n\t\t// (this will only be a false negative if the event is dispatched multiple times and\n\t\t// the fallback document listener isn't reached in between, but that's super rare)\n\t\tvar handler_idx = path.indexOf(handler_element);\n\t\tif (handler_idx === -1) {\n\t\t\t// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)\n\t\t\t// so guard against that, too, and assume that everything was handled at this point.\n\t\t\treturn;\n\t\t}\n\n\t\tif (at_idx <= handler_idx) {\n\t\t\tpath_idx = at_idx;\n\t\t}\n\t}\n\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\n\t// there can only be one delegated event per element, and we either already handled the current target,\n\t// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe\n\t// to handle a possible delegated event on it later (through the root delegation listener for example).\n\tif (current_target === handler_element) return;\n\n\t// Proxy currentTarget to correct target\n\tdefine_property(event, 'currentTarget', {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn current_target || owner_document;\n\t\t}\n\t});\n\n\t// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,\n\t// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic\n\t// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,\n\t// it's probably best that all event handled by Svelte have this behaviour, as we don't really want\n\t// an event handler to run in the context of another reaction or effect.\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\n\ttry {\n\t\t/**\n\t\t * @type {unknown}\n\t\t */\n\t\tvar throw_error;\n\t\t/**\n\t\t * @type {unknown[]}\n\t\t */\n\t\tvar other_errors = [];\n\n\t\twhile (current_target !== null) {\n\t\t\t/** @type {null | Element} */\n\t\t\tvar parent_element =\n\t\t\t\tcurrent_target.assignedSlot ||\n\t\t\t\tcurrent_target.parentNode ||\n\t\t\t\t/** @type {any} */ (current_target).host ||\n\t\t\t\tnull;\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvar delegated = current_target['__' + event_name];\n\n\t\t\t\tif (\n\t\t\t\t\tdelegated != null &&\n\t\t\t\t\t(!(/** @type {any} */ (current_target).disabled) ||\n\t\t\t\t\t\t// DOM could've been updated already by the time this is reached, so we check this as well\n\t\t\t\t\t\t// -> the target could not have been disabled because it emits the event in the first place\n\t\t\t\t\t\tevent.target === current_target)\n\t\t\t\t) {\n\t\t\t\t\tif (is_array(delegated)) {\n\t\t\t\t\t\tvar [fn, ...data] = delegated;\n\t\t\t\t\t\tfn.apply(current_target, [event, ...data]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelegated.call(current_target, event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (throw_error) {\n\t\t\t\t\tother_errors.push(error);\n\t\t\t\t} else {\n\t\t\t\t\tthrow_error = error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (event.cancelBubble || parent_element === handler_element || parent_element === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_target = parent_element;\n\t\t}\n\n\t\tif (throw_error) {\n\t\t\tfor (let error of other_errors) {\n\t\t\t\t// Throw the rest of the errors, one-by-one on a microtask\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow throw_error;\n\t\t}\n\t} finally {\n\t\t// @ts-expect-error is used above\n\t\tevent.__root = handler_element;\n\t\t// @ts-ignore remove proxy on currentTarget\n\t\tdelete event.currentTarget;\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * In dev, warn if an event handler is not a function, as it means the\n * user probably called the handler or forgot to add a `() =>`\n * @param {() => (event: Event, ...args: any) => void} thunk\n * @param {EventTarget} element\n * @param {[Event, ...any]} args\n * @param {any} component\n * @param {[number, number]} [loc]\n * @param {boolean} [remove_parens]\n */\nexport function apply(\n\tthunk,\n\telement,\n\targs,\n\tcomponent,\n\tloc,\n\thas_side_effects = false,\n\tremove_parens = false\n) {\n\tlet handler;\n\tlet error;\n\n\ttry {\n\t\thandler = thunk();\n\t} catch (e) {\n\t\terror = e;\n\t}\n\n\tif (typeof handler !== 'function' && (has_side_effects || handler != null || error)) {\n\t\tconst filename = component?.[FILENAME];\n\t\tconst location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;\n\t\tconst phase = args[0]?.eventPhase < Event.BUBBLING_PHASE ? 'capture' : '';\n\t\tconst event_name = args[0]?.type + phase;\n\t\tconst description = `\\`${event_name}\\` handler${location}`;\n\t\tconst suggestion = remove_parens ? 'remove the trailing `()`' : 'add a leading `() =>`';\n\n\t\tw.event_handler_invalid(description, suggestion);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\t}\n\thandler?.apply(element, args);\n}\n","/** @param {string} html */\nexport function create_fragment_from_html(html) {\n\tvar elem = document.createElement('template');\n\telem.innerHTML = html;\n\treturn elem.content;\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport { create_text, get_first_child, is_firefox } from './operations.js';\nimport { create_fragment_from_html } from './reconciler.js';\nimport { active_effect } from '../runtime.js';\nimport { TEMPLATE_FRAGMENT, TEMPLATE_USE_IMPORT_NODE } from '../../../constants.js';\n\n/**\n * @param {TemplateNode} start\n * @param {TemplateNode | null} end\n */\nexport function assign_nodes(start, end) {\n\tvar effect = /** @type {Effect} */ (active_effect);\n\tif (effect.nodes_start === null) {\n\t\teffect.nodes_start = start;\n\t\teffect.nodes_end = end;\n\t}\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template(content, flags) {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n\n\t/** @type {Node} */\n\tvar node;\n\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (node === undefined) {\n\t\t\tnode = create_fragment_from_html(has_start ? content : '<!>' + content);\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (get_first_child(node));\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (\n\t\t\tuse_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)\n\t\t);\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template_with_script(content, flags) {\n\tvar fn = template(content, flags);\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @param {'svg' | 'math'} ns\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function ns_template(content, flags, ns = 'svg') {\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar wrapped = `<${ns}>${has_start ? content : '<!>' + content}</${ns}>`;\n\n\t/** @type {Element | DocumentFragment} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (!node) {\n\t\t\tvar fragment = /** @type {DocumentFragment} */ (create_fragment_from_html(wrapped));\n\t\t\tvar root = /** @type {Element} */ (get_first_child(fragment));\n\n\t\t\tif (is_fragment) {\n\t\t\t\tnode = document.createDocumentFragment();\n\t\t\t\twhile (get_first_child(root)) {\n\t\t\t\t\tnode.appendChild(/** @type {Node} */ (get_first_child(root)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = /** @type {Element} */ (get_first_child(root));\n\t\t\t}\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (node.cloneNode(true));\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function svg_template_with_script(content, flags) {\n\tvar fn = ns_template(content, flags);\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mathml_template(content, flags) {\n\treturn ns_template(content, flags, 'math');\n}\n\n/**\n * Creating a document fragment from HTML that contains script tags will not execute\n * the scripts. We need to replace the script tags with new ones so that they are executed.\n * @param {Element | DocumentFragment} node\n * @returns {Node | Node[]}\n */\nfunction run_scripts(node) {\n\t// scripts were SSR'd, in which case they will run\n\tif (hydrating) return node;\n\n\tconst is_fragment = node.nodeType === 11;\n\tconst scripts =\n\t\t/** @type {HTMLElement} */ (node).tagName === 'SCRIPT'\n\t\t\t? [/** @type {HTMLScriptElement} */ (node)]\n\t\t\t: node.querySelectorAll('script');\n\tconst effect = /** @type {Effect} */ (active_effect);\n\n\tfor (const script of scripts) {\n\t\tconst clone = document.createElement('script');\n\t\tfor (var attribute of script.attributes) {\n\t\t\tclone.setAttribute(attribute.name, attribute.value);\n\t\t}\n\n\t\tclone.textContent = script.textContent;\n\n\t\t// The script has changed - if it's at the edges, the effect now points at dead nodes\n\t\tif (is_fragment ? node.firstChild === script : node === script) {\n\t\t\teffect.nodes_start = clone;\n\t\t}\n\t\tif (is_fragment ? node.lastChild === script : node === script) {\n\t\t\teffect.nodes_end = clone;\n\t\t}\n\n\t\tscript.replaceWith(clone);\n\t}\n\treturn node;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {any} value\n */\nexport function text(value = '') {\n\tif (!hydrating) {\n\t\tvar t = create_text(value + '');\n\t\tassign_nodes(t, t);\n\t\treturn t;\n\t}\n\n\tvar node = hydrate_node;\n\n\tif (node.nodeType !== 3) {\n\t\t// if an {expression} is empty during SSR, we need to insert an empty text node\n\t\tnode.before((node = create_text()));\n\t\tset_hydrate_node(node);\n\t}\n\n\tassign_nodes(node, node);\n\treturn node;\n}\n\nexport function comment() {\n\t// we're not delegating to `template` here for performance reasons\n\tif (hydrating) {\n\t\tassign_nodes(hydrate_node, null);\n\t\treturn hydrate_node;\n\t}\n\n\tvar frag = document.createDocumentFragment();\n\tvar start = document.createComment('');\n\tvar anchor = create_text();\n\tfrag.append(start, anchor);\n\n\tassign_nodes(start, anchor);\n\n\treturn frag;\n}\n\n/**\n * Assign the created (or in hydration mode, traversed) dom elements to the current block\n * and insert the elements into the dom (in client mode).\n * @param {Text | Comment | Element} anchor\n * @param {DocumentFragment | Element} dom\n */\nexport function append(anchor, dom) {\n\tif (hydrating) {\n\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\n\t\thydrate_next();\n\t\treturn;\n\t}\n\n\tif (anchor === null) {\n\t\t// edge case — void `<svelte:element>` with content\n\t\treturn;\n\t}\n\n\tanchor.before(/** @type {Node} */ (dom));\n}\n\n/**\n * Create (or hydrate) an unique UID for the component instance.\n */\nexport function props_id() {\n\tif (\n\t\thydrating &&\n\t\thydrate_node &&\n\t\thydrate_node.nodeType === 8 &&\n\t\thydrate_node.textContent?.startsWith(`#`)\n\t) {\n\t\tconst id = hydrate_node.textContent.substring(1);\n\t\thydrate_next();\n\t\treturn id;\n\t}\n\n\t// @ts-expect-error This way we ensure the id is unique even across Svelte runtimes\n\t(window.__svelte ??= {}).uid ??= 1;\n\n\t// @ts-expect-error\n\treturn `c${window.__svelte.uid++}`;\n}\n"],"names":["autofocus","dom","value","body","queue_micro_task","remove_textarea_child","hydrating","get_first_child","clear_text_content","listening_to_form_reset","add_form_reset_listener","evt","e","_a","without_reactive_context","fn","previous_reaction","active_reaction","previous_effect","active_effect","set_active_reaction","set_active_effect","listen_to_event_and_reset_event","element","event","handler","on_reset","prev","all_registered_events","root_event_handles","create_event","event_name","options","target_handler","handle_event_propagation","capture","passive","teardown","delegate","events","i","handler_element","owner_document","path","current_target","path_idx","handled_at","at_idx","handler_idx","define_property","throw_error","other_errors","parent_element","delegated","is_array","data","error","create_fragment_from_html","html","elem","assign_nodes","start","end","effect","template","content","flags","is_fragment","TEMPLATE_FRAGMENT","use_import_node","TEMPLATE_USE_IMPORT_NODE","node","has_start","hydrate_node","clone","is_firefox","ns_template","ns","wrapped","fragment","root","text","t","create_text","set_hydrate_node","comment","frag","anchor","append","hydrate_next"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}